<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>AFL源码阅读 - afl-fuzz | ret2ver</title><meta name="author" content="Vergissmeinnicht"><meta name="copyright" content="Vergissmeinnicht"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介afl-fuzz 便是 afl 中的核心文件，模糊测试的代码都在该文件中，从功能上大致可以分为三个部分：  初始配置：进行初始化的配置操作 模糊测试：fuzz 的主要循环过程 变异策略：测试用例的变异策略和实现  初始配置输入参数处理在设置完随机数种子（使用时间 + pid）后，会进行输入参数的处理过程： 12345while ((opt &#x3D; getopt(argc, argv, &quot;">
<meta property="og:type" content="article">
<meta property="og:title" content="AFL源码阅读 - afl-fuzz">
<meta property="og:url" content="https://vergissmeinnichtz.github.io/2022/03/14/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-afl-fuzz/index.html">
<meta property="og:site_name" content="ret2ver">
<meta property="og:description" content="简介afl-fuzz 便是 afl 中的核心文件，模糊测试的代码都在该文件中，从功能上大致可以分为三个部分：  初始配置：进行初始化的配置操作 模糊测试：fuzz 的主要循环过程 变异策略：测试用例的变异策略和实现  初始配置输入参数处理在设置完随机数种子（使用时间 + pid）后，会进行输入参数的处理过程： 12345while ((opt &#x3D; getopt(argc, argv, &quot;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-03-14T09:35:50.000Z">
<meta property="article:modified_time" content="2022-05-04T12:51:26.588Z">
<meta property="article:author" content="Vergissmeinnicht">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vergissmeinnichtz.github.io/2022/03/14/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-afl-fuzz/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'AFL源码阅读 - afl-fuzz',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-04 20:51:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/04/29/RkrKDQiodbYj2eu.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">38</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">32</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ret2ver</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">AFL源码阅读 - afl-fuzz</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-03-14T09:35:50.000Z" title="Created 2022-03-14 17:35:50">2022-03-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-05-04T12:51:26.588Z" title="Updated 2022-05-04 20:51:26">2022-05-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AFL/">AFL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="AFL源码阅读 - afl-fuzz"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>afl-fuzz 便是 afl 中的核心文件，模糊测试的代码都在该文件中，从功能上大致可以分为三个部分：</p>
<ul>
<li>初始配置：进行初始化的配置操作</li>
<li>模糊测试：fuzz 的主要循环过程</li>
<li>变异策略：测试用例的变异策略和实现</li>
</ul>
<h1 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h1><h2 id="输入参数处理"><a href="#输入参数处理" class="headerlink" title="输入参数处理"></a>输入参数处理</h2><p>在设置完随机数种子（使用时间 + pid）后，会进行输入参数的处理过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;+i:o:f:m:b:t:T:dnCB:S:M:x:QV&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">			<span class="comment">// opt</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>大致的可输入参数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz <span class="number">2.57b</span> by &lt;lcamtuf@google.com&gt;</span><br><span class="line"></span><br><span class="line">afl-fuzz [ options ] -- /path/to/fuzzed_app [ ... ]</span><br><span class="line"></span><br><span class="line">Required parameters:</span><br><span class="line"></span><br><span class="line">  -i dir        - input directory with test cases</span><br><span class="line">  -o dir        - output directory <span class="keyword">for</span> fuzzer findings</span><br><span class="line"></span><br><span class="line">Execution control settings:</span><br><span class="line"></span><br><span class="line">  -f file       - location read by the fuzzed <span class="title function_">program</span> <span class="params">(<span class="built_in">stdin</span>)</span></span><br><span class="line">  -t msec       - timeout <span class="keyword">for</span> each <span class="title function_">run</span> <span class="params">(<span class="keyword">auto</span>-scaled, <span class="number">50</span><span class="number">-1000</span> ms)</span></span><br><span class="line">  -m megs       - memory limit <span class="keyword">for</span> child <span class="title function_">process</span> <span class="params">(<span class="number">50</span> MB)</span></span><br><span class="line">  -Q            - use binary-only <span class="title function_">instrumentation</span> <span class="params">(QEMU mode)</span></span><br><span class="line"></span><br><span class="line">Fuzzing behavior settings:</span><br><span class="line"></span><br><span class="line">  -d            - quick &amp; dirty <span class="title function_">mode</span> <span class="params">(skips deterministic steps)</span></span><br><span class="line">  -n            - fuzz without <span class="title function_">instrumentation</span> <span class="params">(dumb mode)</span></span><br><span class="line">  -x dir        - optional fuzzer <span class="title function_">dictionary</span> <span class="params">(see README)</span></span><br><span class="line"></span><br><span class="line">Other stuff:</span><br><span class="line"></span><br><span class="line">  -T text       - text banner to show on the screen</span><br><span class="line">  -M / -S id    - distributed <span class="title function_">mode</span> <span class="params">(see parallel_fuzzing.txt)</span></span><br><span class="line">  -C            - crash exploration <span class="title function_">mode</span> <span class="params">(the peruvian rabbit thing)</span></span><br><span class="line">  -V            - show version number and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">  -b cpu_id     - bind the fuzzing process to the specified CPU core</span><br><span class="line"></span><br><span class="line">For additional tips, please consult /usr/local/share/doc/afl/README.</span><br></pre></td></tr></table></figure>

<h2 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h2><p>初始化 sigaction 结构体，然后使用 sigemptyset 函数初始化信号量集合，最后使用 sigaction 注册信号处理函数并设置信号句柄，具体而言设置了以下的信号量：</p>
<ul>
<li>SIGHUP&#x2F;SIGINT&#x2F;SIGTERM ：处理各种停止的情况</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Handle stop signal (Ctrl-C, etc). */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_stop_sig</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line"></span><br><span class="line">  stop_soon = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) kill(child_pid, SIGKILL);</span><br><span class="line">  <span class="keyword">if</span> (forksrv_pid &gt; <span class="number">0</span>) kill(forksrv_pid, SIGKILL);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>SIGALRM ：处理超时情况</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Handle timeout (SIGALRM). */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_timeout</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    child_timed_out = <span class="number">1</span>; </span><br><span class="line">    kill(child_pid, SIGKILL);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child_pid == <span class="number">-1</span> &amp;&amp; forksrv_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    child_timed_out = <span class="number">1</span>; </span><br><span class="line">    kill(forksrv_pid, SIGKILL);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>SIGWINCH ：处理重新设置窗口大小情况</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Handle screen resize (SIGWINCH). */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_resize</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  clear_screen = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>SIGUSR1 ：用户自定义信号，处理 skip request</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Handle skip request (SIGUSR1). */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_skipreq</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line"></span><br><span class="line">  skip_requested = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>SIGTSTP&#x2F;SIGPIPE ：忽略的情况</li>
</ul>
<h2 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts"></a>check_asan_opts</h2><p>主要是处理 asan 的各种配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_asan_opts</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8* x = getenv(<span class="string">&quot;ASAN_OPTIONS&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;abort_on_error=1&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;symbolize=0&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;Custom ASAN_OPTIONS set without symbolize=0 - please fix!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  x = getenv(<span class="string">&quot;MSAN_OPTIONS&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR)))</span><br><span class="line">      FATAL(<span class="string">&quot;Custom MSAN_OPTIONS set without exit_code=&quot;</span></span><br><span class="line">            STRINGIFY(MSAN_ERROR) <span class="string">&quot; - please fix!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;symbolize=0&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;Custom MSAN_OPTIONS set without symbolize=0 - please fix!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是从环境变量中读取 ASAN_OPTIONS 和 MSAN_OPTIONS 并进行检查</p>
<h2 id="fix-up-sync"><a href="#fix-up-sync" class="headerlink" title="fix_up_sync"></a>fix_up_sync</h2><p>如果通过 -M &#x2F; -S 设置了 sync_id ， 就会进入到 fix_up_sync 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Validate and fix up out_dir and sync_dir when using -S. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fix_up_sync</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8* x = sync_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode)</span><br><span class="line">    FATAL(<span class="string">&quot;-S / -M and -n are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_deterministic) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (force_deterministic)</span><br><span class="line">      FATAL(<span class="string">&quot;use -S instead of -M -d&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      FATAL(<span class="string">&quot;-S already implies -d&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*x) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(*x) &amp;&amp; *x != <span class="string">&#x27;_&#x27;</span> &amp;&amp; *x != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">      FATAL(<span class="string">&quot;Non-alphanumeric fuzzer ID specified via -S or -M&quot;</span>);</span><br><span class="line"></span><br><span class="line">    x++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(sync_id) &gt; <span class="number">32</span>) FATAL(<span class="string">&quot;Fuzzer ID too long&quot;</span>);</span><br><span class="line"></span><br><span class="line">  x = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, out_dir, sync_id);</span><br><span class="line"></span><br><span class="line">  sync_dir = out_dir;</span><br><span class="line">  out_dir  = x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!force_deterministic) &#123;</span><br><span class="line">    skip_deterministic = <span class="number">1</span>;</span><br><span class="line">    use_splicing = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做了一些冲突和输入检查，最后设置 sync_dir 和 out_dir 分别为之前的 out_dir 和 out_dir + sync_id</p>
<h2 id="输入的检查和环境变量的读取"><a href="#输入的检查和环境变量的读取" class="headerlink" title="输入的检查和环境变量的读取"></a>输入的检查和环境变量的读取</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, out_dir))</span><br><span class="line">    FATAL(<span class="string">&quot;Input and output directories can&#x27;t be the same&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (crash_mode) FATAL(<span class="string">&quot;-C and -n are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (qemu_mode)  FATAL(<span class="string">&quot;-Q and -n are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_FORKSRV&quot;</span>))    no_forkserver    = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_CPU_RED&quot;</span>))    no_cpu_meter_red = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_ARITH&quot;</span>))      no_arith         = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_SHUFFLE_QUEUE&quot;</span>)) shuffle_queue    = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_FAST_CAL&quot;</span>))      fast_cal         = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>)) &#123;</span><br><span class="line">    hang_tmout = atoi(getenv(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!hang_tmout) FATAL(<span class="string">&quot;Invalid value of AFL_HANG_TMOUT&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">2</span> &amp;&amp; no_forkserver)</span><br><span class="line">    FATAL(<span class="string">&quot;AFL_DUMB_FORKSRV and AFL_NO_FORKSRV are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>)) &#123;</span><br><span class="line">    setenv(<span class="string">&quot;LD_PRELOAD&quot;</span>, getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    setenv(<span class="string">&quot;DYLD_INSERT_LIBRARIES&quot;</span>, getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_LD_PRELOAD&quot;</span>))</span><br><span class="line">    FATAL(<span class="string">&quot;Use AFL_PRELOAD instead of AFL_LD_PRELOAD&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>主要是对输入的一些 mode 进行冲突检查，随后读取环境变量并进行设置</p>
<h2 id="save-cmdline"><a href="#save-cmdline" class="headerlink" title="save_cmdline"></a>save_cmdline</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Make a copy of the current command line. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">save_cmdline</span><span class="params">(u32 argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 len = <span class="number">1</span>, i;</span><br><span class="line">  u8* buf;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    len += <span class="built_in">strlen</span>(argv[i]) + <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  buf = orig_cmdline = ck_alloc(len);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 l = <span class="built_in">strlen</span>(argv[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(buf, argv[i], l);</span><br><span class="line">    buf += l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i != argc - <span class="number">1</span>) *(buf++) = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *buf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 argv 进行备份存储</p>
<h2 id="fix-up-banner"><a href="#fix-up-banner" class="headerlink" title="fix_up_banner"></a>fix_up_banner</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Trim and possibly create a banner for the run. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fix_up_banner</span><span class="params">(u8* name)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!use_banner) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sync_id) &#123;</span><br><span class="line"></span><br><span class="line">      use_banner = sync_id;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      u8* trim = <span class="built_in">strrchr</span>(name, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (!trim) use_banner = name; <span class="keyword">else</span> use_banner = trim + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(use_banner) &gt; <span class="number">40</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u8* tmp = ck_alloc(<span class="number">44</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%.40s...&quot;</span>, use_banner);</span><br><span class="line">    use_banner = tmp;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是修剪并创建 banner</p>
<h2 id="check-if-tty"><a href="#check-if-tty" class="headerlink" title="check_if_tty"></a>check_if_tty</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if we&#x27;re on TTY. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_if_tty</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">ws</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_UI&quot;</span>)) &#123;</span><br><span class="line">    OKF(<span class="string">&quot;Disabling the UI because AFL_NO_UI is set.&quot;</span>);</span><br><span class="line">    not_on_tty = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ioctl(<span class="number">1</span>, TIOCGWINSZ, &amp;ws)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno == ENOTTY) &#123;</span><br><span class="line">      OKF(<span class="string">&quot;Looks like we&#x27;re not running on a tty, so I&#x27;ll be a bit less verbose.&quot;</span>);</span><br><span class="line">      not_on_tty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查是否在 tty 终端上运行</p>
<ul>
<li>如果有环境变量 AFL_NO_UI 则设置 not_on_tty 为 1</li>
<li>通过 ioctl 读取 windows size ，如果报错为 ENOTTY 则设置 not_on_tty 为 1</li>
</ul>
<h2 id="get-core-count"><a href="#get-core-count" class="headerlink" title="get_core_count"></a>get_core_count</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Count the number of logical CPU cores. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">get_core_count</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 cur_runnable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__)</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> s = <span class="keyword">sizeof</span>(cpu_core_count);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* On *BSD systems, we can just use a sysctl to get the number of CPUs. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sysctlbyname(<span class="string">&quot;hw.logicalcpu&quot;</span>, &amp;cpu_core_count, &amp;s, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> s_name[<span class="number">2</span>] = &#123; CTL_HW, HW_NCPU &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sysctl(s_name, <span class="number">2</span>, &amp;cpu_core_count, &amp;s, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line"></span><br><span class="line">  cpu_core_count = sysconf(_SC_NPROCESSORS_ONLN);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  FILE* f = fopen(<span class="string">&quot;/proc/stat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  u8 tmp[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!f) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (fgets(tmp, <span class="keyword">sizeof</span>(tmp), f))</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(tmp, <span class="string">&quot;cpu&quot;</span>, <span class="number">3</span>) &amp;&amp; <span class="built_in">isdigit</span>(tmp[<span class="number">3</span>])) cpu_core_count++;</span><br><span class="line"></span><br><span class="line">  fclose(f);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^HAVE_AFFINITY */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^(__APPLE__ || __FreeBSD__ || __OpenBSD__) */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cpu_core_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    cur_runnable = (u32)get_runnable_processes();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add ourselves, since the 1-minute average doesn&#x27;t include that yet. */</span></span><br><span class="line"></span><br><span class="line">    cur_runnable++;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ || __FreeBSD__ || __OpenBSD__ */</span></span></span><br><span class="line"></span><br><span class="line">    OKF(<span class="string">&quot;You have %u CPU core%s and %u runnable tasks (utilization: %0.0f%%).&quot;</span>,</span><br><span class="line">        cpu_core_count, cpu_core_count &gt; <span class="number">1</span> ? <span class="string">&quot;s&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">        cur_runnable, cur_runnable * <span class="number">100.0</span> / cpu_core_count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpu_core_count &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cur_runnable &gt; cpu_core_count * <span class="number">1.5</span>) &#123;</span><br><span class="line"></span><br><span class="line">        WARNF(<span class="string">&quot;System under apparent load, performance may be spotty.&quot;</span>);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_runnable + <span class="number">1</span> &lt;= cpu_core_count) &#123;</span><br><span class="line"></span><br><span class="line">        OKF(<span class="string">&quot;Try parallel jobs - see %s/parallel_fuzzing.txt.&quot;</span>, doc_path);</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    cpu_core_count = <span class="number">0</span>;</span><br><span class="line">    WARNF(<span class="string">&quot;Unable to figure out the number of CPU cores.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 &#x2F;proc&#x2F;stat 中获取 CPU 核心数</p>
<h2 id="bind-to-free-cpu"><a href="#bind-to-free-cpu" class="headerlink" title="bind_to_free_cpu"></a>bind_to_free_cpu</h2><p>如果有宏定义 HAVE_AFFINITY 则进入 bind_to_free_cpu（在 linux 下默认为 1 ）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Build a list of processes bound to specific cores. Returns -1 if nothing</span></span><br><span class="line"><span class="comment">   can be found. Assumes an upper bound of 4k CPUs. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">bind_to_free_cpu</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  DIR* d;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">de</span>;</span></span><br><span class="line">  <span class="type">cpu_set_t</span> c;</span><br><span class="line"></span><br><span class="line">  u8 cpu_used[<span class="number">4096</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cpu_core_count &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_AFFINITY&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    WARNF(<span class="string">&quot;Not binding to a CPU core (AFL_NO_AFFINITY set).&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  d = opendir(<span class="string">&quot;/proc&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!d) &#123;</span><br><span class="line"></span><br><span class="line">    WARNF(<span class="string">&quot;Unable to access /proc - can&#x27;t scan for free CPU cores.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Checking CPU core loadout...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Introduce some jitter, in case multiple AFL tasks are doing the same</span></span><br><span class="line"><span class="comment">     thing at the same time... */</span></span><br><span class="line"></span><br><span class="line">  usleep(R(<span class="number">1000</span>) * <span class="number">250</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Scan all /proc/&lt;pid&gt;/status entries, checking for Cpus_allowed_list.</span></span><br><span class="line"><span class="comment">     Flag all processes bound to a specific CPU using cpu_used[]. This will</span></span><br><span class="line"><span class="comment">     fail for some exotic binding setups, but is likely good enough in almost</span></span><br><span class="line"><span class="comment">     all real-world use cases. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((de = readdir(d))) &#123;</span><br><span class="line"></span><br><span class="line">    u8* fn;</span><br><span class="line">    FILE* f;</span><br><span class="line">    u8 tmp[MAX_LINE];</span><br><span class="line">    u8 has_vmsize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(de-&gt;d_name[<span class="number">0</span>])) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;/proc/%s/status&quot;</span>, de-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(f = fopen(fn, <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">      ck_free(fn);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(tmp, MAX_LINE, f)) &#123;</span><br><span class="line"></span><br><span class="line">      u32 hval;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Processes without VmSize are probably kernel tasks. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(tmp, <span class="string">&quot;VmSize:\t&quot;</span>, <span class="number">8</span>)) has_vmsize = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(tmp, <span class="string">&quot;Cpus_allowed_list:\t&quot;</span>, <span class="number">19</span>) &amp;&amp;</span><br><span class="line">          !<span class="built_in">strchr</span>(tmp, <span class="string">&#x27;-&#x27;</span>) &amp;&amp; !<span class="built_in">strchr</span>(tmp, <span class="string">&#x27;,&#x27;</span>) &amp;&amp;</span><br><span class="line">          <span class="built_in">sscanf</span>(tmp + <span class="number">19</span>, <span class="string">&quot;%u&quot;</span>, &amp;hval) == <span class="number">1</span> &amp;&amp; hval &lt; <span class="keyword">sizeof</span>(cpu_used) &amp;&amp;</span><br><span class="line">          has_vmsize) &#123;</span><br><span class="line"></span><br><span class="line">        cpu_used[hval] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ck_free(fn);</span><br><span class="line">    fclose(f);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  closedir(d);</span><br><span class="line">  <span class="keyword">if</span> (cpu_to_bind_given) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpu_to_bind &gt;= cpu_core_count)</span><br><span class="line">      FATAL(<span class="string">&quot;The CPU core id to bind should be between 0 and %u&quot;</span>, cpu_core_count - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cpu_used[cpu_to_bind])</span><br><span class="line">      FATAL(<span class="string">&quot;The CPU core #%u to bind is not free!&quot;</span>, cpu_to_bind);</span><br><span class="line"></span><br><span class="line">    i = cpu_to_bind;</span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cpu_core_count; i++) <span class="keyword">if</span> (!cpu_used[i]) <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (i == cpu_core_count) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Uh-oh, looks like all %u CPU cores on your system are allocated to\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    other instances of afl-fuzz (or similar CPU-locked tasks). Starting\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    another fuzzer on this machine is probably a bad plan, but if you are\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    absolutely sure, you can set AFL_NO_AFFINITY and try again.\n&quot;</span>,</span><br><span class="line">         cpu_core_count);</span><br><span class="line"></span><br><span class="line">    FATAL(<span class="string">&quot;No more free CPU cores&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;Found a free CPU core, binding to #%u.&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">  cpu_aff = i;</span><br><span class="line"></span><br><span class="line">  CPU_ZERO(&amp;c);</span><br><span class="line">  CPU_SET(i, &amp;c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(c), &amp;c))</span><br><span class="line">    PFATAL(<span class="string">&quot;sched_setaffinity failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* HAVE_AFFINITY */</span></span></span><br></pre></td></tr></table></figure>

<p>通过读取 &#x2F;proc 下的内容构建绑定到特定核心的进程列表</p>
<h2 id="check-crash-handling"><a href="#check-crash-handling" class="headerlink" title="check_crash_handling"></a>check_crash_handling</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Make sure that core dumps don&#x27;t go to a program. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_crash_handling</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Yuck! There appears to be no simple C API to query for the state of </span></span><br><span class="line"><span class="comment">     loaded daemons on MacOS X, and I&#x27;m a bit hesitant to do something</span></span><br><span class="line"><span class="comment">     more sophisticated, such as disabling crash reporting via Mach ports,</span></span><br><span class="line"><span class="comment">     until I get a box to test the code. So, for now, we check for crash</span></span><br><span class="line"><span class="comment">     reporting the awful way. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (system(<span class="string">&quot;launchctl list 2&gt;/dev/null | grep -q &#x27;\\.ReportCrash$&#x27;&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">       <span class="string">&quot;Whoops, your system is configured to forward crash notifications to an\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    external crash reporting utility. This will cause issues due to the\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    extended delay between the fuzzed binary malfunctioning and this fact\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    being relayed to the fuzzer via the standard waitpid() API.\n\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    To avoid having crashes misinterpreted as timeouts, please run the\n&quot;</span> </span><br><span class="line">       <span class="string">&quot;    following commands:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="string">&quot;    SL=/System/Library; PL=com.apple.ReportCrash\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    launchctl unload -w $&#123;SL&#125;/LaunchAgents/$&#123;PL&#125;.plist\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    sudo launchctl unload -w $&#123;SL&#125;/LaunchDaemons/$&#123;PL&#125;.Root.plist\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES&quot;</span>))</span><br><span class="line">    FATAL(<span class="string">&quot;Crash reporter detected&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is Linux specific, but I don&#x27;t think there&#x27;s anything equivalent on</span></span><br><span class="line"><span class="comment">     *BSD, so we can just let it slide for now. */</span></span><br><span class="line"></span><br><span class="line">  s32 fd = open(<span class="string">&quot;/proc/sys/kernel/core_pattern&quot;</span>, O_RDONLY);</span><br><span class="line">  u8  fchar;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Checking core_pattern...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read(fd, &amp;fchar, <span class="number">1</span>) == <span class="number">1</span> &amp;&amp; fchar == <span class="string">&#x27;|&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Hmm, your system is configured to send core dump notifications to an\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    external utility. This will cause issues: there will be an extended delay\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    between stumbling upon a crash and having this information relayed to the\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    fuzzer via the standard waitpid() API.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;    To avoid having crashes misinterpreted as timeouts, please log in as root\n&quot;</span> </span><br><span class="line">         <span class="string">&quot;    and temporarily modify /proc/sys/kernel/core_pattern, like so:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;    echo core &gt;/proc/sys/kernel/core_pattern\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;Pipe at the beginning of &#x27;core_pattern&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保 core dumps 不会转储进入程序</p>
<h2 id="check-cpu-governor"><a href="#check-cpu-governor" class="headerlink" title="check_cpu_governor"></a>check_cpu_governor</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check CPU governor. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_cpu_governor</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  FILE* f;</span><br><span class="line">  u8 tmp[<span class="number">128</span>];</span><br><span class="line">  u64 min = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_SKIP_CPUFREQ&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  f = fopen(<span class="string">&quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!f) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Checking CPU scaling governor...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fgets(tmp, <span class="number">128</span>, f)) PFATAL(<span class="string">&quot;fgets() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fclose(f);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(tmp, <span class="string">&quot;perf&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  f = fopen(<span class="string">&quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (f) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fscanf</span>(f, <span class="string">&quot;%llu&quot;</span>, &amp;min) != <span class="number">1</span>) min = <span class="number">0</span>;</span><br><span class="line">    fclose(f);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f = fopen(<span class="string">&quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (f) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fscanf</span>(f, <span class="string">&quot;%llu&quot;</span>, &amp;max) != <span class="number">1</span>) max = <span class="number">0</span>;</span><br><span class="line">    fclose(f);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (min == max) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">       <span class="string">&quot;Whoops, your system uses on-demand CPU frequency scaling, adjusted\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    between %llu and %llu MHz. Unfortunately, the scaling algorithm in the\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    kernel is imperfect and can miss the short-lived processes spawned by\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    afl-fuzz. To keep things moving, run these commands as root:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="string">&quot;    cd /sys/devices/system/cpu\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    echo performance | tee cpu*/cpufreq/scaling_governor\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="string">&quot;    You can later go back to the original state by replacing &#x27;performance&#x27; with\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    &#x27;ondemand&#x27;. If you don&#x27;t want to change the settings, set AFL_SKIP_CPUFREQ\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    to make afl-fuzz skip this check - but expect some performance drop.\n&quot;</span>,</span><br><span class="line">       min / <span class="number">1024</span>, max / <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Suboptimal CPU scaling governor&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过读取 &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F; 下的一些内容检查 CPU 管理者</p>
<h2 id="setup-post"><a href="#setup-post" class="headerlink" title="setup_post"></a>setup_post</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Load postprocessor, if available. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">setup_post</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* dh;</span><br><span class="line">  u8* fn = getenv(<span class="string">&quot;AFL_POST_LIBRARY&quot;</span>);</span><br><span class="line">  u32 tlen = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fn) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Loading postprocessor from &#x27;%s&#x27;...&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">  dh = dlopen(fn, RTLD_NOW);</span><br><span class="line">  <span class="keyword">if</span> (!dh) FATAL(<span class="string">&quot;%s&quot;</span>, dlerror());</span><br><span class="line"></span><br><span class="line">  post_handler = dlsym(dh, <span class="string">&quot;afl_postprocess&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!post_handler) FATAL(<span class="string">&quot;Symbol &#x27;afl_postprocess&#x27; not found.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Do a quick test. It&#x27;s better to segfault now than later =) */</span></span><br><span class="line"></span><br><span class="line">  post_handler(<span class="string">&quot;hello&quot;</span>, &amp;tlen);</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;Postprocessor installed successfully.&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载 postprocessor</p>
<h2 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm"></a>setup_shm</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Configure shared memory and virgin_bits. This is called at startup. */</span></span><br><span class="line"></span><br><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">setup_shm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8* shm_str;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用 shmget 分配共享内存并保存至 shm_id</span></span><br><span class="line">  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册 atexit handler 为 remove_shm</span></span><br><span class="line">  atexit(remove_shm); </span><br><span class="line"></span><br><span class="line">  shm_str = alloc_printf(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不是 dumb mode ，设置 shm_str 到 SHM_ENV_VAR</span></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ck_free(shm_str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动对共享内存的访问，返回一个指向共享内存第一个字节的指针</span></span><br><span class="line">  trace_bits = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (trace_bits == (<span class="type">void</span> *)<span class="number">-1</span>) PFATAL(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get rid of shared memory and temp files (atexit handler). */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_shm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  unlink(prog_in); <span class="comment">/* Ignore errors */</span></span><br><span class="line">  shmctl(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 in_bitmap 为空，则填充 virgin_bits 为 255</li>
<li>填充 virgin_tmout 和 virgin_crash 为 255</li>
<li>调用 shmget 申请共享内存，如果出错则抛出异常</li>
<li>注册 atexit handler 为 remove_shm<ul>
<li>remove_shm 进行了 unlink 和 shmctl</li>
</ul>
</li>
<li>如果不是 dumb mode ，设置 shm_str 到 SHM_ENV_VAR</li>
<li>调用 shmat 启动对共享内存的访问，并把共享内存指针赋值给 trace_bits</li>
</ul>
<p>这里通过 trace_bits 和 virgin_bits 两个 bitmap 来分别记录当前的 tuple 及整体的 tuple 信息</p>
<ul>
<li>trace_bits 位于共享内存上，用于进程间通信</li>
<li>virgin_tmout 和 virgin_crash 记录 fuzz 过程中出现的所有目标程序超时及崩溃的 tuple 信息</li>
</ul>
<p>另外，MAP_SIZE 为 65536</p>
<h2 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16"></a>init_count_class16</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Destructively classify execution counts in a trace. This is used as a</span></span><br><span class="line"><span class="comment">   preprocessing step for any newly acquired traces. Called on every exec,</span></span><br><span class="line"><span class="comment">   must be fast. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>,</span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>,</span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>,</span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>,</span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>,</span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u16 count_class_lookup16[<span class="number">65536</span>];</span><br><span class="line"></span><br><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">init_count_class16</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 b1, b2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (b1 = <span class="number">0</span>; b1 &lt; <span class="number">256</span>; b1++) </span><br><span class="line">    <span class="keyword">for</span> (b2 = <span class="number">0</span>; b2 &lt; <span class="number">256</span>; b2++)</span><br><span class="line">      count_class_lookup16[(b1 &lt;&lt; <span class="number">8</span>) + b2] = </span><br><span class="line">        (count_class_lookup8[b1] &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">        count_class_lookup8[b2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>trace_bits 是用一个字节来记录是否到达这个路径，并且命中了多少次。这个值在 0 - 255 之间。count_class_lookup8 数组用来将这些次数做了一个规整，比如 4 - 7 次的计数都默认为 8 次。</p>
<p>而 AFL 中对一条分支路径的表示通常由一个二元组来进行表示，后面 AFL 进行规整的时候也是读取的两个字节，为了提高效率便使用了 count_class_lookup16 。（拿空间换时间）</p>
<h2 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds"></a>setup_dirs_fds</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prepare output directories and fds. */</span></span><br><span class="line"></span><br><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">setup_dirs_fds</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8* tmp;</span><br><span class="line">  s32 fd;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Setting up output directories...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sync_id &amp;&amp; mkdir(sync_dir, <span class="number">0700</span>) &amp;&amp; errno != EEXIST)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, sync_dir);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mkdir(out_dir, <span class="number">0700</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno != EEXIST) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, out_dir);</span><br><span class="line"></span><br><span class="line">    maybe_delete_out_dir();</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_place_resume)</span><br><span class="line">      FATAL(<span class="string">&quot;Resume attempted but old output directory not found&quot;</span>);</span><br><span class="line"></span><br><span class="line">    out_dir_fd = open(out_dir, O_RDONLY);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __sun</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (out_dir_fd &lt; <span class="number">0</span> || flock(out_dir_fd, LOCK_EX | LOCK_NB))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to flock() output directory.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !__sun */</span></span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Queue directory for any starting &amp; discovered paths. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Top-level directory for queue metadata used for session</span></span><br><span class="line"><span class="comment">     resume and related tasks. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Directory for flagging queue entries that went through</span></span><br><span class="line"><span class="comment">     deterministic fuzzing in the past. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/deterministic_done/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Directory with the auto-selected dictionary entries. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/auto_extras/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The set of paths currently deemed redundant. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/redundant_edges/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The set of paths showing variable behavior. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/variable_behavior/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sync directory for keeping track of cooperating fuzzers. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sync_id) &#123;</span><br><span class="line"></span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/.synced/&quot;</span>, out_dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>) &amp;&amp; (!in_place_resume || errno != EEXIST))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line"></span><br><span class="line">    ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* All recorded crashes. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/crashes&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* All recorded hangs. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/hangs&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Generally useful file descriptors. */</span></span><br><span class="line"></span><br><span class="line">  dev_null_fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (dev_null_fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open /dev/null&quot;</span>);</span><br><span class="line"></span><br><span class="line">  dev_urandom_fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (dev_urandom_fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open /dev/urandom&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Gnuplot output file. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/plot_data&quot;</span>, out_dir);</span><br><span class="line">  fd = open(tmp, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  plot_file = fdopen(fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!plot_file) PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(plot_file, <span class="string">&quot;# unix_time, cycles_done, cur_path, paths_total, &quot;</span></span><br><span class="line">                     <span class="string">&quot;pending_total, pending_favs, map_size, unique_crashes, &quot;</span></span><br><span class="line">                     <span class="string">&quot;unique_hangs, max_depth, execs_per_sec\n&quot;</span>);</span><br><span class="line">                     <span class="comment">/* ignore errors */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提前初始化 out_dir 目录下的各个子目录</p>
<h2 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases"></a>read_testcases</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Read all testcases from the input directory, then queue them for testing.</span></span><br><span class="line"><span class="comment">   Called at startup. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_testcases</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">nl</span>;</span></span><br><span class="line">  s32 nl_cnt;</span><br><span class="line">  u32 i;</span><br><span class="line">  u8* fn;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Auto-detect non-in-place resumption attempts. */</span></span><br><span class="line"></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/queue&quot;</span>, in_dir);</span><br><span class="line">  <span class="keyword">if</span> (!access(fn, F_OK)) in_dir = fn; <span class="keyword">else</span> ck_free(fn);</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Scanning &#x27;%s&#x27;...&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We use scandir() + alphasort() rather than readdir() because otherwise,</span></span><br><span class="line"><span class="comment">     the ordering  of test cases would vary somewhat randomly and would be</span></span><br><span class="line"><span class="comment">     difficult to control. */</span></span><br><span class="line"></span><br><span class="line">  nl_cnt = scandir(in_dir, &amp;nl, <span class="literal">NULL</span>, alphasort);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nl_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno == ENOENT || errno == ENOTDIR)</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;The input directory does not seem to be valid - try again. The fuzzer needs\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    one or more test case to start with - ideally, a small file under 1 kB\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    or so. The cases must be stored as regular files directly in the input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    directory.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shuffle_queue &amp;&amp; nl_cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    ACTF(<span class="string">&quot;Shuffling queue...&quot;</span>);</span><br><span class="line">    shuffle_ptrs((<span class="type">void</span>**)nl, nl_cnt);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nl_cnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    u8* fn = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line">    u8* dfn = alloc_printf(<span class="string">&quot;%s/.state/deterministic_done/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    u8  passed_det = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(nl[i]); <span class="comment">/* not tracked */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (lstat(fn, &amp;st) || access(fn, R_OK))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to access &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This also takes care of . and .. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!S_ISREG(st.st_mode) || !st.st_size || <span class="built_in">strstr</span>(fn, <span class="string">&quot;/README.testcases&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      ck_free(fn);</span><br><span class="line">      ck_free(dfn);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; MAX_FILE) </span><br><span class="line">      FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; is too big (%s, limit is %s)&quot;</span>, fn,</span><br><span class="line">            DMS(st.st_size), DMS(MAX_FILE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for metadata that indicates that deterministic fuzzing</span></span><br><span class="line"><span class="comment">       is complete for this entry. We don&#x27;t want to repeat deterministic</span></span><br><span class="line"><span class="comment">       fuzzing when resuming aborted scans, because it would be pointless</span></span><br><span class="line"><span class="comment">       and probably very time-consuming. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!access(dfn, F_OK)) passed_det = <span class="number">1</span>;</span><br><span class="line">    ck_free(dfn);</span><br><span class="line"></span><br><span class="line">    add_to_queue(fn, st.st_size, passed_det);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(nl); <span class="comment">/* not tracked */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!queued_paths) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Looks like there are no valid test cases in the input directory! The fuzzer\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    needs one or more test case to start with - ideally, a small file under\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    1 kB or so. The cases must be stored as regular files directly in the\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    input directory.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FATAL(<span class="string">&quot;No usable test cases in &#x27;%s&#x27;&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  last_path_time = <span class="number">0</span>;</span><br><span class="line">  queued_at_start = queued_paths;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 in_dir 中读取所有测试用例，测试用例大小不能大于 100MB。同时不加载变异的输入测试用例。最后调用 add_to_queue 函数将测试用例加入队列。</p>
<h2 id="add-to-queue"><a href="#add-to-queue" class="headerlink" title="add_to_queue"></a>add_to_queue</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Append new test case to the queue. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_to_queue</span><span class="params">(u8* fname, u32 len, u8 passed_det)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> =</span> ck_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> queue_entry));</span><br><span class="line"></span><br><span class="line">  q-&gt;fname        = fname;</span><br><span class="line">  q-&gt;len          = len;</span><br><span class="line">  q-&gt;depth        = cur_depth + <span class="number">1</span>;</span><br><span class="line">  q-&gt;passed_det   = passed_det;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;depth &gt; max_depth) max_depth = q-&gt;depth;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_top) &#123;</span><br><span class="line"></span><br><span class="line">    queue_top-&gt;next = q;</span><br><span class="line">    queue_top = q;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> q_prev100 = <span class="built_in">queue</span> = queue_top = q;</span><br><span class="line"></span><br><span class="line">  queued_paths++;</span><br><span class="line">  pending_not_fuzzed++;</span><br><span class="line"></span><br><span class="line">  cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set next_100 pointer for every 100th element (index 0, 100, etc) to allow faster iteration. */</span></span><br><span class="line">  <span class="keyword">if</span> ((queued_paths - <span class="number">1</span>) % <span class="number">100</span> == <span class="number">0</span> &amp;&amp; queued_paths &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    q_prev100-&gt;next_100 = q;</span><br><span class="line">    q_prev100 = q;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  last_path_time = get_cur_time();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将测试用例加入队列，会初始化 fname 文件名称，增加 cur_depth 、queued_paths 和 pending_not_fuzzed 等参数，并初始化 last_path_time</p>
<h2 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto"></a>load_auto</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Load automatically generated extras. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">load_auto</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; USE_AUTO_EXTRAS; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u8  tmp[MAX_AUTO_EXTRA + <span class="number">1</span>];</span><br><span class="line">    u8* fn = alloc_printf(<span class="string">&quot;%s/.state/auto_extras/auto_%06u&quot;</span>, in_dir, i);</span><br><span class="line">    s32 fd, len;</span><br><span class="line"></span><br><span class="line">    fd = open(fn, O_RDONLY, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (errno != ENOENT) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">      ck_free(fn);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We read one byte more to cheaply detect tokens that are too</span></span><br><span class="line"><span class="comment">       long (and skip them). */</span></span><br><span class="line"></span><br><span class="line">    len = read(fd, tmp, MAX_AUTO_EXTRA + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to read from &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt;= MIN_AUTO_EXTRA &amp;&amp; len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">      maybe_add_auto(tmp, len);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    ck_free(fn);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (i) OKF(<span class="string">&quot;Loaded %u auto-discovered dictionary tokens.&quot;</span>, i);</span><br><span class="line">  <span class="keyword">else</span> OKF(<span class="string">&quot;No auto-generated dictionary tokens to reuse.&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载自动生成的额外内容</p>
<h2 id="pivot-inputs"><a href="#pivot-inputs" class="headerlink" title="pivot_inputs"></a>pivot_inputs</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create hard links for input test cases in the output directory, choosing</span></span><br><span class="line"><span class="comment">   good names and pivoting accordingly. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pivot_inputs</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> =</span> <span class="built_in">queue</span>;</span><br><span class="line">  u32 id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Creating hard links for all input files...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line"></span><br><span class="line">    u8  *nfn, *rsl = <span class="built_in">strrchr</span>(q-&gt;fname, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    u32 orig_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!rsl) rsl = q-&gt;fname; <span class="keyword">else</span> rsl++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the original file name conforms to the syntax and the recorded</span></span><br><span class="line"><span class="comment">       ID matches the one we&#x27;d assign, just use the original file name.</span></span><br><span class="line"><span class="comment">       This is valuable for resuming fuzzing runs. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> CASE_PREFIX <span class="string">&quot;id:&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> CASE_PREFIX <span class="string">&quot;id_&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(rsl, CASE_PREFIX, <span class="number">3</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">sscanf</span>(rsl + <span class="number">3</span>, <span class="string">&quot;%06u&quot;</span>, &amp;orig_id) == <span class="number">1</span> &amp;&amp; orig_id == id) &#123;</span><br><span class="line"></span><br><span class="line">      u8* src_str;</span><br><span class="line">      u32 src_id;</span><br><span class="line"></span><br><span class="line">      resuming_fuzz = <span class="number">1</span>;</span><br><span class="line">      nfn = alloc_printf(<span class="string">&quot;%s/queue/%s&quot;</span>, out_dir, rsl);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Since we&#x27;re at it, let&#x27;s also try to find parent and figure out the</span></span><br><span class="line"><span class="comment">         appropriate depth for this entry. */</span></span><br><span class="line"></span><br><span class="line">      src_str = <span class="built_in">strchr</span>(rsl + <span class="number">3</span>, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (src_str &amp;&amp; <span class="built_in">sscanf</span>(src_str + <span class="number">1</span>, <span class="string">&quot;%06u&quot;</span>, &amp;src_id) == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">s</span> =</span> <span class="built_in">queue</span>;</span><br><span class="line">        <span class="keyword">while</span> (src_id-- &amp;&amp; s) s = s-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (s) q-&gt;depth = s-&gt;depth + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (max_depth &lt; q-&gt;depth) max_depth = q-&gt;depth;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* No dice - invent a new name, capturing the original one as a</span></span><br><span class="line"><span class="comment">         substring. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"></span><br><span class="line">      u8* use_name = <span class="built_in">strstr</span>(rsl, <span class="string">&quot;,orig:&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (use_name) use_name += <span class="number">6</span>; <span class="keyword">else</span> use_name = rsl;</span><br><span class="line">      nfn = alloc_printf(<span class="string">&quot;%s/queue/id:%06u,orig:%s&quot;</span>, out_dir, id, use_name);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      nfn = alloc_printf(<span class="string">&quot;%s/queue/id_%06u&quot;</span>, out_dir, id);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pivot to the new queue entry. */</span></span><br><span class="line"></span><br><span class="line">    link_or_copy(q-&gt;fname, nfn);</span><br><span class="line">    ck_free(q-&gt;fname);</span><br><span class="line">    q-&gt;fname = nfn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure that the passed_det value carries over, too. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;passed_det) mark_as_det_done(q);</span><br><span class="line"></span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">    id++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_place_resume) nuke_resume_dir();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark deterministic checks as done for a particular queue entry. We use the</span></span><br><span class="line"><span class="comment">   .state file to avoid repeating deterministic fuzzing when resuming aborted</span></span><br><span class="line"><span class="comment">   scans. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mark_as_det_done</span><span class="params">(<span class="keyword">struct</span> queue_entry* q)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8* fn = <span class="built_in">strrchr</span>(q-&gt;fname, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  s32 fd;</span><br><span class="line"></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/queue/.state/deterministic_done/%s&quot;</span>, out_dir, fn + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  q-&gt;passed_det = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete the temporary directory used for in-place session resume. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nuke_resume_dir</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8* fn;</span><br><span class="line"></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/_resume/.state/deterministic_done&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, CASE_PREFIX)) <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/_resume/.state/auto_extras&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, <span class="string">&quot;auto_&quot;</span>)) <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/_resume/.state/redundant_edges&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, CASE_PREFIX)) <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/_resume/.state/variable_behavior&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, CASE_PREFIX)) <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/_resume/.state&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (rmdir(fn) &amp;&amp; errno != ENOENT) <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/_resume&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, CASE_PREFIX)) <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">dir_cleanup_failed:</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;_resume directory cleanup failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在输出目录中为输入测试用例（从队列中挨个取出）创建硬链接</p>
<h2 id="load-extras"><a href="#load-extras" class="headerlink" title="load_extras"></a>load_extras</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Read extras from the extras directory and sort them by size. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">load_extras</span><span class="params">(u8* dir)</span> &#123;</span><br><span class="line"></span><br><span class="line">  DIR* d;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">de</span>;</span></span><br><span class="line">  u32 min_len = MAX_DICT_FILE, max_len = <span class="number">0</span>, dict_level = <span class="number">0</span>;</span><br><span class="line">  u8* x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the name ends with @, extract level and continue. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((x = <span class="built_in">strchr</span>(dir, <span class="string">&#x27;@&#x27;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">    *x = <span class="number">0</span>;</span><br><span class="line">    dict_level = atoi(x + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Loading extra dictionary from &#x27;%s&#x27; (level %u)...&quot;</span>, dir, dict_level);</span><br><span class="line"></span><br><span class="line">  d = opendir(dir);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!d) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno == ENOTDIR) &#123;</span><br><span class="line">      load_extras_file(dir, &amp;min_len, &amp;max_len, dict_level);</span><br><span class="line">      <span class="keyword">goto</span> check_and_sort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x) FATAL(<span class="string">&quot;Dictionary levels not supported for directories.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((de = readdir(d))) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    u8* fn = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, dir, de-&gt;d_name);</span><br><span class="line">    s32 fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lstat(fn, &amp;st) || access(fn, R_OK))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to access &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This also takes care of . and .. */</span></span><br><span class="line">    <span class="keyword">if</span> (!S_ISREG(st.st_mode) || !st.st_size) &#123;</span><br><span class="line"></span><br><span class="line">      ck_free(fn);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; MAX_DICT_FILE)</span><br><span class="line">      FATAL(<span class="string">&quot;Extra &#x27;%s&#x27; is too big (%s, limit is %s)&quot;</span>, fn,</span><br><span class="line">            DMS(st.st_size), DMS(MAX_DICT_FILE));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (min_len &gt; st.st_size) min_len = st.st_size;</span><br><span class="line">    <span class="keyword">if</span> (max_len &lt; st.st_size) max_len = st.st_size;</span><br><span class="line"></span><br><span class="line">    extras = ck_realloc_block(extras, (extras_cnt + <span class="number">1</span>) *</span><br><span class="line">               <span class="keyword">sizeof</span>(<span class="keyword">struct</span> extra_data));</span><br><span class="line"></span><br><span class="line">    extras[extras_cnt].data = ck_alloc(st.st_size);</span><br><span class="line">    extras[extras_cnt].len  = st.st_size;</span><br><span class="line"></span><br><span class="line">    fd = open(fn, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    ck_read(fd, extras[extras_cnt].data, st.st_size, fn);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    ck_free(fn);</span><br><span class="line"></span><br><span class="line">    extras_cnt++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  closedir(d);</span><br><span class="line"></span><br><span class="line">check_and_sort:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!extras_cnt) FATAL(<span class="string">&quot;No usable files in &#x27;%s&#x27;&quot;</span>, dir);</span><br><span class="line"></span><br><span class="line">  qsort(extras, extras_cnt, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> extra_data), compare_extras_len);</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;Loaded %u extra tokens, size range %s to %s.&quot;</span>, extras_cnt,</span><br><span class="line">      DMS(min_len), DMS(max_len));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (max_len &gt; <span class="number">32</span>)</span><br><span class="line">    WARNF(<span class="string">&quot;Some tokens are relatively large (%s) - consider trimming.&quot;</span>,</span><br><span class="line">          DMS(max_len));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (extras_cnt &gt; MAX_DET_EXTRAS)</span><br><span class="line">    WARNF(<span class="string">&quot;More than %u tokens - will use them probabilistically.&quot;</span>,</span><br><span class="line">          MAX_DET_EXTRAS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read extras from a file, sort by size. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">load_extras_file</span><span class="params">(u8* fname, u32* min_len, u32* max_len,</span></span><br><span class="line"><span class="params">                             u32 dict_level)</span> &#123;</span><br><span class="line"></span><br><span class="line">  FILE* f;</span><br><span class="line">  u8  buf[MAX_LINE];</span><br><span class="line">  u8  *lptr;</span><br><span class="line">  u32 cur_line = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  f = fopen(fname, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!f) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, fname);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((lptr = fgets(buf, MAX_LINE, f))) &#123;</span><br><span class="line"></span><br><span class="line">    u8 *rptr, *wptr;</span><br><span class="line">    u32 klen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cur_line++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Trim on left and right. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isspace</span>(*lptr)) lptr++;</span><br><span class="line"></span><br><span class="line">    rptr = lptr + <span class="built_in">strlen</span>(lptr) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (rptr &gt;= lptr &amp;&amp; <span class="built_in">isspace</span>(*rptr)) rptr--;</span><br><span class="line">    rptr++;</span><br><span class="line">    *rptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip empty lines and comments. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!*lptr || *lptr == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All other lines must end with &#x27;&quot;&#x27;, which we can consume. */</span></span><br><span class="line"></span><br><span class="line">    rptr--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rptr &lt; lptr || *rptr != <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">      FATAL(<span class="string">&quot;Malformed name=\&quot;value\&quot; pair in line %u.&quot;</span>, cur_line);</span><br><span class="line"></span><br><span class="line">    *rptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip alphanumerics and dashes (label). */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isalnum</span>(*lptr) || *lptr == <span class="string">&#x27;_&#x27;</span>) lptr++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If @number follows, parse that. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*lptr == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">      lptr++;</span><br><span class="line">      <span class="keyword">if</span> (atoi(lptr) &gt; dict_level) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*lptr)) lptr++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip whitespace and = signs. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isspace</span>(*lptr) || *lptr == <span class="string">&#x27;=&#x27;</span>) lptr++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Consume opening &#x27;&quot;&#x27;. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*lptr != <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">      FATAL(<span class="string">&quot;Malformed name=\&quot;keyword\&quot; pair in line %u.&quot;</span>, cur_line);</span><br><span class="line"></span><br><span class="line">    lptr++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!*lptr) FATAL(<span class="string">&quot;Empty keyword in line %u.&quot;</span>, cur_line);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Okay, let&#x27;s allocate memory and copy data between &quot;...&quot;, handling</span></span><br><span class="line"><span class="comment">       \xNN escaping, \\, and \&quot;. */</span></span><br><span class="line"></span><br><span class="line">    extras = ck_realloc_block(extras, (extras_cnt + <span class="number">1</span>) *</span><br><span class="line">               <span class="keyword">sizeof</span>(<span class="keyword">struct</span> extra_data));</span><br><span class="line"></span><br><span class="line">    wptr = extras[extras_cnt].data = ck_alloc(rptr - lptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*lptr) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">char</span>* hexdigits = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (*lptr) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> ... <span class="number">31</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">128</span> ... <span class="number">255</span>:</span><br><span class="line">          FATAL(<span class="string">&quot;Non-printable characters in line %u.&quot;</span>, cur_line);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line"></span><br><span class="line">          lptr++;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (*lptr == <span class="string">&#x27;\\&#x27;</span> || *lptr == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">            *(wptr++) = *(lptr++);</span><br><span class="line">            klen++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (*lptr != <span class="string">&#x27;x&#x27;</span> || !<span class="built_in">isxdigit</span>(lptr[<span class="number">1</span>]) || !<span class="built_in">isxdigit</span>(lptr[<span class="number">2</span>]))</span><br><span class="line">            FATAL(<span class="string">&quot;Invalid escaping (not \\xNN) in line %u.&quot;</span>, cur_line);</span><br><span class="line"></span><br><span class="line">          *(wptr++) =</span><br><span class="line">            ((<span class="built_in">strchr</span>(hexdigits, <span class="built_in">tolower</span>(lptr[<span class="number">1</span>])) - hexdigits) &lt;&lt; <span class="number">4</span>) |</span><br><span class="line">            (<span class="built_in">strchr</span>(hexdigits, <span class="built_in">tolower</span>(lptr[<span class="number">2</span>])) - hexdigits);</span><br><span class="line"></span><br><span class="line">          lptr += <span class="number">3</span>;</span><br><span class="line">          klen++;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">          *(wptr++) = *(lptr++);</span><br><span class="line">          klen++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    extras[extras_cnt].len = klen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (extras[extras_cnt].len &gt; MAX_DICT_FILE)</span><br><span class="line">      FATAL(<span class="string">&quot;Keyword too big in line %u (%s, limit is %s)&quot;</span>, cur_line,</span><br><span class="line">            DMS(klen), DMS(MAX_DICT_FILE));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*min_len &gt; klen) *min_len = klen;</span><br><span class="line">    <span class="keyword">if</span> (*max_len &lt; klen) *max_len = klen;</span><br><span class="line"></span><br><span class="line">    extras_cnt++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fclose(f);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果传入的参数有 extras_dir ，则从 extras_dir 中读取额外数据并按照大小排序。同时会要求读取的额外数据都是可打印字符</p>
<h2 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout"></a>find_timeout</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The same, but for timeouts. The idea is that when resuming sessions without</span></span><br><span class="line"><span class="comment">   -t given, we don&#x27;t want to keep auto-scaling the timeout over and over</span></span><br><span class="line"><span class="comment">   again to prevent it from growing due to random flukes. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">find_timeout</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 tmp[<span class="number">4096</span>]; <span class="comment">/* Ought to be enough for anybody. */</span></span><br><span class="line"></span><br><span class="line">  u8  *fn, *off;</span><br><span class="line">  s32 fd, i;</span><br><span class="line">  u32 ret;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!resuming_fuzz) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_place_resume) fn = alloc_printf(<span class="string">&quot;%s/fuzzer_stats&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">else</span> fn = alloc_printf(<span class="string">&quot;%s/../fuzzer_stats&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  fd = open(fn, O_RDONLY);</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  i = read(fd, tmp, <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>); (<span class="type">void</span>)i; <span class="comment">/* Ignore errors */</span></span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">  off = <span class="built_in">strstr</span>(tmp, <span class="string">&quot;exec_timeout      : &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!off) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  ret = atoi(off + <span class="number">20</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt;= <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  exec_tmout = ret;</span><br><span class="line">  timeout_given = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有指定 timeout 时间，则初始化 exec_tmout 和 timeout_given 防止每次都自动调整超时时间</p>
<h2 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args"></a>detect_file_args</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Detect @@ in args. */</span></span><br><span class="line"></span><br><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">detect_file_args</span><span class="params">(<span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 i = <span class="number">0</span>;</span><br><span class="line">  u8* cwd = getcwd(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!cwd) PFATAL(<span class="string">&quot;getcwd() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (argv[i]) &#123;</span><br><span class="line"></span><br><span class="line">    u8* aa_loc = <span class="built_in">strstr</span>(argv[i], <span class="string">&quot;@@&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aa_loc) &#123;</span><br><span class="line"></span><br><span class="line">      u8 *aa_subst, *n_arg;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we don&#x27;t have a file name chosen yet, use a safe default. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!out_file)</span><br><span class="line">        out_file = alloc_printf(<span class="string">&quot;%s/.cur_input&quot;</span>, out_dir);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Be sure that we&#x27;re always using fully-qualified paths. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (out_file[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) aa_subst = out_file;</span><br><span class="line">      <span class="keyword">else</span> aa_subst = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, cwd, out_file);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Construct a replacement argv value. */</span></span><br><span class="line"></span><br><span class="line">      *aa_loc = <span class="number">0</span>;</span><br><span class="line">      n_arg = alloc_printf(<span class="string">&quot;%s%s%s&quot;</span>, argv[i], aa_subst, aa_loc + <span class="number">2</span>);</span><br><span class="line">      argv[i] = n_arg;</span><br><span class="line">      *aa_loc = <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (out_file[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) ck_free(aa_subst);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(cwd); <span class="comment">/* not tracked */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>识别输入是否有 @@ （占位符），如果有且 out_file 为空则将 out_file 替换为 out_dir&#x2F;.cur_input</p>
<h2 id="setup-stdio-file"><a href="#setup-stdio-file" class="headerlink" title="setup_stdio_file"></a>setup_stdio_file</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Setup the output file for fuzzed data, if not using -f. */</span></span><br><span class="line"></span><br><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">setup_stdio_file</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8* fn = alloc_printf(<span class="string">&quot;%s/.cur_input&quot;</span>, out_dir);</span><br><span class="line"></span><br><span class="line">  unlink(fn); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line">  out_fd = open(fn, O_RDWR | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (out_fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 out_file 为空则设置 output 文件</p>
<h2 id="check-binary"><a href="#check-binary" class="headerlink" title="check_binary"></a>check_binary</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Do a PATH search and find target binary to see that it exists and</span></span><br><span class="line"><span class="comment">   isn&#x27;t a shell script - a common and painful mistake. We also check for</span></span><br><span class="line"><span class="comment">   a valid ELF header and for evidence of AFL instrumentation. */</span></span><br><span class="line"></span><br><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">check_binary</span><span class="params">(u8* fname)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8* env_path = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  s32 fd;</span><br><span class="line">  u8* f_data;</span><br><span class="line">  u32 f_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Validating target binary...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strchr</span>(fname, <span class="string">&#x27;/&#x27;</span>) || !(env_path = getenv(<span class="string">&quot;PATH&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">    target_path = ck_strdup(fname);</span><br><span class="line">    <span class="keyword">if</span> (stat(target_path, &amp;st) || !S_ISREG(st.st_mode) ||</span><br><span class="line">        !(st.st_mode &amp; <span class="number">0111</span>) || (f_len = st.st_size) &lt; <span class="number">4</span>)</span><br><span class="line">      FATAL(<span class="string">&quot;Program &#x27;%s&#x27; not found or not executable&quot;</span>, fname);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (env_path) &#123;</span><br><span class="line"></span><br><span class="line">      u8 *cur_elem, *delim = <span class="built_in">strchr</span>(env_path, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (delim) &#123;</span><br><span class="line"></span><br><span class="line">        cur_elem = ck_alloc(delim - env_path + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(cur_elem, env_path, delim - env_path);</span><br><span class="line">        delim++;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> cur_elem = ck_strdup(env_path);</span><br><span class="line"></span><br><span class="line">      env_path = delim;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cur_elem[<span class="number">0</span>])</span><br><span class="line">        target_path = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, cur_elem, fname);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        target_path = ck_strdup(fname);</span><br><span class="line"></span><br><span class="line">      ck_free(cur_elem);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!stat(target_path, &amp;st) &amp;&amp; S_ISREG(st.st_mode) &amp;&amp;</span><br><span class="line">          (st.st_mode &amp; <span class="number">0111</span>) &amp;&amp; (f_len = st.st_size) &gt;= <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      ck_free(target_path);</span><br><span class="line">      target_path = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!target_path) FATAL(<span class="string">&quot;Program &#x27;%s&#x27; not found or not executable&quot;</span>, fname);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_SKIP_BIN_CHECK&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check for blatant user errors. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((!<span class="built_in">strncmp</span>(target_path, <span class="string">&quot;/tmp/&quot;</span>, <span class="number">5</span>) &amp;&amp; !<span class="built_in">strchr</span>(target_path + <span class="number">5</span>, <span class="string">&#x27;/&#x27;</span>)) ||</span><br><span class="line">      (!<span class="built_in">strncmp</span>(target_path, <span class="string">&quot;/var/tmp/&quot;</span>, <span class="number">9</span>) &amp;&amp; !<span class="built_in">strchr</span>(target_path + <span class="number">9</span>, <span class="string">&#x27;/&#x27;</span>)))</span><br><span class="line">     FATAL(<span class="string">&quot;Please don&#x27;t keep binaries in /tmp or /var/tmp&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd = open(target_path, O_RDONLY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, target_path);</span><br><span class="line"></span><br><span class="line">  f_data = mmap(<span class="number">0</span>, f_len, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (f_data == MAP_FAILED) PFATAL(<span class="string">&quot;Unable to mmap file &#x27;%s&#x27;&quot;</span>, target_path);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (f_data[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; f_data[<span class="number">1</span>] == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Oops, the target binary looks like a shell script. Some build systems will\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    sometimes generate shell stubs for dynamically linked programs; try static\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    library mode (./configure --disable-shared) if that&#x27;s the case.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;    Another possible cause is that you are actually trying to use a shell\n&quot;</span> </span><br><span class="line">         <span class="string">&quot;    wrapper around the fuzzed component. Invoking shell can slow down the\n&quot;</span> </span><br><span class="line">         <span class="string">&quot;    fuzzing process by a factor of 20x or more; it&#x27;s best to write the wrapper\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    in a compiled language instead.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FATAL(<span class="string">&quot;Program &#x27;%s&#x27; is a shell script&quot;</span>, target_path);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (f_data[<span class="number">0</span>] != <span class="number">0x7f</span> || <span class="built_in">memcmp</span>(f_data + <span class="number">1</span>, <span class="string">&quot;ELF&quot;</span>, <span class="number">3</span>))</span><br><span class="line">    FATAL(<span class="string">&quot;Program &#x27;%s&#x27; is not an ELF binary&quot;</span>, target_path);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (f_data[<span class="number">0</span>] != <span class="number">0xCF</span> || f_data[<span class="number">1</span>] != <span class="number">0xFA</span> || f_data[<span class="number">2</span>] != <span class="number">0xED</span>)</span><br><span class="line">    FATAL(<span class="string">&quot;Program &#x27;%s&#x27; is not a 64-bit Mach-O binary&quot;</span>, target_path);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!__APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!qemu_mode &amp;&amp; !dumb_mode &amp;&amp;</span><br><span class="line">      !memmem(f_data, f_len, SHM_ENV_VAR, <span class="built_in">strlen</span>(SHM_ENV_VAR) + <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Looks like the target binary is not instrumented! The fuzzer depends on\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    compile-time instrumentation to isolate interesting test cases while\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    mutating the input data. For more information, and for tips on how to\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    instrument binaries, please see %s/README.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;    When source code is not available, you may be able to leverage QEMU\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    mode support. Consult the README for tips on how to enable this.\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;    (It is also possible to use afl-fuzz as a traditional, \&quot;dumb\&quot; fuzzer.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    For that, you can use the -n option - but expect much worse results.)\n&quot;</span>,</span><br><span class="line">         doc_path);</span><br><span class="line"></span><br><span class="line">    FATAL(<span class="string">&quot;No instrumentation detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (qemu_mode &amp;&amp;</span><br><span class="line">      memmem(f_data, f_len, SHM_ENV_VAR, <span class="built_in">strlen</span>(SHM_ENV_VAR) + <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;This program appears to be instrumented with afl-gcc, but is being run in\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    QEMU mode (-Q). This is probably not what you want - this setup will be\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    slow and offer no practical benefits.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FATAL(<span class="string">&quot;Instrumentation found in -Q mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (memmem(f_data, f_len, <span class="string">&quot;libasan.so&quot;</span>, <span class="number">10</span>) ||</span><br><span class="line">      memmem(f_data, f_len, <span class="string">&quot;__msan_init&quot;</span>, <span class="number">11</span>)) uses_asan = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Detect persistent &amp; deferred init signatures in the binary. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (memmem(f_data, f_len, PERSIST_SIG, <span class="built_in">strlen</span>(PERSIST_SIG) + <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    OKF(cPIN <span class="string">&quot;Persistent mode binary detected.&quot;</span>);</span><br><span class="line">    setenv(PERSIST_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    persistent_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_PERSISTENT&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    WARNF(<span class="string">&quot;AFL_PERSISTENT is no longer supported and may misbehave!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (memmem(f_data, f_len, DEFER_SIG, <span class="built_in">strlen</span>(DEFER_SIG) + <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    OKF(cPIN <span class="string">&quot;Deferred forkserver binary detected.&quot;</span>);</span><br><span class="line">    setenv(DEFER_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    deferred_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_DEFER_FORKSRV&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    WARNF(<span class="string">&quot;AFL_DEFER_FORKSRV is no longer supported and may misbehave!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (munmap(f_data, f_len)) PFATAL(<span class="string">&quot;unmap() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行路径搜索，检查目标二进制文件是否存在且不是 shell 脚本，同时也会检查 ELF 头来确保目标二进制文件是正确格式</p>
<h1 id="首次-Fuzz"><a href="#首次-Fuzz" class="headerlink" title="首次 Fuzz"></a>首次 Fuzz</h1><h2 id="start-time"><a href="#start-time" class="headerlink" title="start_time"></a>start_time</h2><p>调用 get_cur_time() 函数获取 start_time</p>
<h2 id="get-qemu-argv"><a href="#get-qemu-argv" class="headerlink" title="get_qemu_argv"></a>get_qemu_argv</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (qemu_mode)</span><br><span class="line">    use_argv = get_qemu_argv(argv[<span class="number">0</span>], argv + optind, argc - optind);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    use_argv = argv + optind;</span><br></pre></td></tr></table></figure>

<p>如果是 qemu_mode 的话则通过 get_qemu_argv 获取 use_argv</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Rewrite argv for QEMU. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>** <span class="title function_">get_qemu_argv</span><span class="params">(u8* own_loc, <span class="type">char</span>** argv, <span class="type">int</span> argc)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>** new_argv = ck_alloc(<span class="keyword">sizeof</span>(<span class="type">char</span>*) * (argc + <span class="number">4</span>));</span><br><span class="line">  u8 *tmp, *cp, *rsl, *own_copy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Workaround for a QEMU stability glitch. */</span></span><br><span class="line"></span><br><span class="line">  setenv(<span class="string">&quot;QEMU_LOG&quot;</span>, <span class="string">&quot;nochain&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(new_argv + <span class="number">3</span>, argv + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>*) * argc);</span><br><span class="line"></span><br><span class="line">  new_argv[<span class="number">2</span>] = target_path;</span><br><span class="line">  new_argv[<span class="number">1</span>] = <span class="string">&quot;--&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now we need to actually find the QEMU binary to put in argv[0]. */</span></span><br><span class="line"></span><br><span class="line">  tmp = getenv(<span class="string">&quot;AFL_PATH&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line"></span><br><span class="line">    cp = alloc_printf(<span class="string">&quot;%s/afl-qemu-trace&quot;</span>, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (access(cp, X_OK))</span><br><span class="line">      FATAL(<span class="string">&quot;Unable to find &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line"></span><br><span class="line">    target_path = new_argv[<span class="number">0</span>] = cp;</span><br><span class="line">    <span class="keyword">return</span> new_argv;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  own_copy = ck_strdup(own_loc);</span><br><span class="line">  rsl = <span class="built_in">strrchr</span>(own_copy, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rsl) &#123;</span><br><span class="line"></span><br><span class="line">    *rsl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cp = alloc_printf(<span class="string">&quot;%s/afl-qemu-trace&quot;</span>, own_copy);</span><br><span class="line">    ck_free(own_copy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!access(cp, X_OK)) &#123;</span><br><span class="line"></span><br><span class="line">      target_path = new_argv[<span class="number">0</span>] = cp;</span><br><span class="line">      <span class="keyword">return</span> new_argv;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> ck_free(own_copy);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!access(BIN_PATH <span class="string">&quot;/afl-qemu-trace&quot;</span>, X_OK)) &#123;</span><br><span class="line"></span><br><span class="line">    target_path = new_argv[<span class="number">0</span>] = ck_strdup(BIN_PATH <span class="string">&quot;/afl-qemu-trace&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> new_argv;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">       <span class="string">&quot;Oops, unable to find the &#x27;afl-qemu-trace&#x27; binary. The binary must be built\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    separately by following the instructions in qemu_mode/README.qemu. If you\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    already have the binary installed, you may need to specify AFL_PATH in the\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="string">&quot;    Of course, even without QEMU, afl-fuzz can still work with binaries that are\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    instrumented at compile time with afl-gcc. It is also possible to use it as a\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    traditional \&quot;dumb\&quot; fuzzer by specifying &#x27;-n&#x27; in the command line.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Failed to locate &#x27;afl-qemu-trace&#x27;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要能够找到 afl-qemu-trace 文件</p>
<h2 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run"></a>perform_dry_run</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Perform dry run of all test cases to confirm that the app is working as</span></span><br><span class="line"><span class="comment">   expected. This is done only for the initial inputs, and only once. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">perform_dry_run</span><span class="params">(<span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> =</span> <span class="built_in">queue</span>;</span><br><span class="line">  u32 cal_failures = <span class="number">0</span>;</span><br><span class="line">  u8* skip_crashes = getenv(<span class="string">&quot;AFL_SKIP_CRASHES&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line"></span><br><span class="line">    u8* use_mem;</span><br><span class="line">    u8  res;</span><br><span class="line">    s32 fd;</span><br><span class="line"></span><br><span class="line">    u8* fn = <span class="built_in">strrchr</span>(q-&gt;fname, <span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ACTF(<span class="string">&quot;Attempting dry run with &#x27;%s&#x27;...&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    fd = open(q-&gt;fname, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    use_mem = ck_alloc_nozero(q-&gt;len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, use_mem, q-&gt;len) != q-&gt;len)</span><br><span class="line">      FATAL(<span class="string">&quot;Short read from &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    res = calibrate_case(argv, q, use_mem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    ck_free(use_mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == crash_mode || res == FAULT_NOBITS)</span><br><span class="line">      SAYF(cGRA <span class="string">&quot;    len = %u, map size = %u, exec speed = %llu us\n&quot;</span> cRST, </span><br><span class="line">           q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_NONE:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q == <span class="built_in">queue</span>) check_map_coverage();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (crash_mode) FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; does *NOT* crash&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_TMOUT:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout_given) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* The -t nn+ syntax in the command line sets timeout_given to &#x27;2&#x27; and</span></span><br><span class="line"><span class="comment">             instructs afl-fuzz to tolerate but skip queue entries that time</span></span><br><span class="line"><span class="comment">             out. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (timeout_given &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            WARNF(<span class="string">&quot;Test case results in a timeout (skipping)&quot;</span>);</span><br><span class="line">            q-&gt;cal_failed = CAL_CHANCES;</span><br><span class="line">            cal_failures++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">               <span class="string">&quot;The program took more than %u ms to process one of the initial test cases.\n&quot;</span></span><br><span class="line">               <span class="string">&quot;    Usually, the right thing to do is to relax the -t option - or to delete it\n&quot;</span></span><br><span class="line">               <span class="string">&quot;    altogether and allow the fuzzer to auto-calibrate. That said, if you know\n&quot;</span></span><br><span class="line">               <span class="string">&quot;    what you are doing and want to simply skip the unruly test cases, append\n&quot;</span></span><br><span class="line">               <span class="string">&quot;    &#x27;+&#x27; at the end of the value passed to -t (&#x27;-t %u+&#x27;).\n&quot;</span>, exec_tmout,</span><br><span class="line">               exec_tmout);</span><br><span class="line"></span><br><span class="line">          FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; results in a timeout&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">               <span class="string">&quot;The program took more than %u ms to process one of the initial test cases.\n&quot;</span></span><br><span class="line">               <span class="string">&quot;    This is bad news; raising the limit with the -t option is possible, but\n&quot;</span></span><br><span class="line">               <span class="string">&quot;    will probably make the fuzzing process extremely slow.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">               <span class="string">&quot;    If this test case is just a fluke, the other option is to just avoid it\n&quot;</span></span><br><span class="line">               <span class="string">&quot;    altogether, and find one that is less of a CPU hog.\n&quot;</span>, exec_tmout);</span><br><span class="line"></span><br><span class="line">          FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; results in a timeout&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_CRASH:  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (crash_mode) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skip_crashes) &#123;</span><br><span class="line">          WARNF(<span class="string">&quot;Test case results in a crash (skipping)&quot;</span>);</span><br><span class="line">          q-&gt;cal_failed = CAL_CHANCES;</span><br><span class="line">          cal_failures++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mem_limit) &#123;</span><br><span class="line"></span><br><span class="line">          SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">               <span class="string">&quot;Oops, the program crashed with one of the test cases provided. There are\n&quot;</span></span><br><span class="line">               <span class="string">&quot;    several possible explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">               <span class="string">&quot;    - The test case causes known crashes under normal working conditions. If\n&quot;</span></span><br><span class="line">               <span class="string">&quot;      so, please remove it. The fuzzer should be seeded with interesting\n&quot;</span></span><br><span class="line">               <span class="string">&quot;      inputs - but not ones that cause an outright crash.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">               <span class="string">&quot;    - The current memory limit (%s) is too low for this program, causing\n&quot;</span></span><br><span class="line">               <span class="string">&quot;      it to die due to OOM when parsing valid files. To fix this, try\n&quot;</span></span><br><span class="line">               <span class="string">&quot;      bumping it up with the -m setting in the command line. If in doubt,\n&quot;</span></span><br><span class="line">               <span class="string">&quot;      try something along the lines of:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">               <span class="string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/binary [...] &lt;testcase )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">               <span class="string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/binary [...] &lt;testcase )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">               <span class="string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span></span><br><span class="line">               <span class="string">&quot;      estimate the required amount of virtual memory for the binary. Also,\n&quot;</span></span><br><span class="line">               <span class="string">&quot;      if you are using ASAN, see %s/notes_for_asan.txt.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">  </span><br><span class="line">               <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span></span><br><span class="line">               <span class="string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span></span><br><span class="line">               <span class="string">&quot;      binaries. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">               <span class="string">&quot;    - Least likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">               <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,</span><br><span class="line">               DMS(mem_limit &lt;&lt; <span class="number">20</span>), mem_limit - <span class="number">1</span>, doc_path);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">               <span class="string">&quot;Oops, the program crashed with one of the test cases provided. There are\n&quot;</span></span><br><span class="line">               <span class="string">&quot;    several possible explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">               <span class="string">&quot;    - The test case causes known crashes under normal working conditions. If\n&quot;</span></span><br><span class="line">               <span class="string">&quot;      so, please remove it. The fuzzer should be seeded with interesting\n&quot;</span></span><br><span class="line">               <span class="string">&quot;      inputs - but not ones that cause an outright crash.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">  </span><br><span class="line">               <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span></span><br><span class="line">               <span class="string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span></span><br><span class="line">               <span class="string">&quot;      binaries. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">               <span class="string">&quot;    - Least likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">               <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; results in a crash&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_ERROR:</span><br><span class="line"></span><br><span class="line">        FATAL(<span class="string">&quot;Unable to execute target application (&#x27;%s&#x27;)&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_NOINST:</span><br><span class="line"></span><br><span class="line">        FATAL(<span class="string">&quot;No instrumentation detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_NOBITS: </span><br><span class="line"></span><br><span class="line">        useless_at_start++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!in_bitmap &amp;&amp; !shuffle_queue)</span><br><span class="line">          WARNF(<span class="string">&quot;No new instrumentation output, test case may be useless.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;var_behavior) WARNF(<span class="string">&quot;Instrumentation output varies across runs.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    q = q-&gt;next;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cal_failures) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cal_failures == queued_paths)</span><br><span class="line">      FATAL(<span class="string">&quot;All test cases time out%s, giving up!&quot;</span>,</span><br><span class="line">            skip_crashes ? <span class="string">&quot; or crash&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WARNF(<span class="string">&quot;Skipped %u test cases (%0.02f%%) due to timeouts%s.&quot;</span>, cal_failures,</span><br><span class="line">          ((<span class="type">double</span>)cal_failures) * <span class="number">100</span> / queued_paths,</span><br><span class="line">          skip_crashes ? <span class="string">&quot; or crashes&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cal_failures * <span class="number">5</span> &gt; queued_paths)</span><br><span class="line">      WARNF(cLRD <span class="string">&quot;High percentage of rejected test cases, check settings!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;All test cases processed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数会执行所有的测试用例并检查是否运行正确：</p>
<ul>
<li>读取环境变量 AFL_SKIP_CRASHES 到 skip_crashes ，并获取测试用例的队列和设置 cal_failures 为 0</li>
<li>挨个遍历测试用例队列<ul>
<li>使用 ck_alloc_nozero 根据测试用例长度分配内存给 use_mem ，然后把测试用例读取到 use_mem 中，其中 ck_alloc_nozero 就是 DFL_ck_alloc_nozero</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ck_alloc_nozero   DFL_ck_alloc_nozero</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_OFF_HEAD  8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_OFF_TOTAL (ALLOC_OFF_HEAD + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate a buffer, explicitly not zeroing it. Returns NULL for zero-sized</span></span><br><span class="line"><span class="comment">   requests. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>* <span class="title function_">DFL_ck_alloc_nozero</span><span class="params">(u32 size)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* ret;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!size) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  ALLOC_CHECK_SIZE(size);</span><br><span class="line">  ret = <span class="built_in">malloc</span>(size + ALLOC_OFF_TOTAL);</span><br><span class="line">  ALLOC_CHECK_RESULT(ret, size);</span><br><span class="line"></span><br><span class="line">  ret += ALLOC_OFF_HEAD;</span><br><span class="line"></span><br><span class="line">  ALLOC_C1(ret) = ALLOC_MAGIC_C1;</span><br><span class="line">  ALLOC_S(ret)  = size;</span><br><span class="line">  ALLOC_C2(ret) = ALLOC_MAGIC_C2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 calibrate_case 函数校准测试用例并返回测试结果，由于 calibrate_case 函数较大后面再介绍</li>
<li>如果有 stop_soon 则返回</li>
<li>如果结果是 crash_mode 或 FAULT_NOBITS 则打印一些信息</li>
<li>随后根据结果进行不同的处理<ul>
<li>FAULT_NONE<ul>
<li>如果是第一个测试用例，调用 check_map_coverage 函数</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_SIZE_POW2       16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_SIZE            (1 &lt;&lt; MAP_SIZE_POW2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF(_b)  (0xff &lt;&lt; ((_b) &lt;&lt; 3))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Count the number of bytes set in the bitmap. Called fairly sporadically,</span></span><br><span class="line"><span class="comment">   mostly to update the status screen or calibrate and examine confirmed</span></span><br><span class="line"><span class="comment">   new paths. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u32 <span class="title function_">count_bytes</span><span class="params">(u8* mem)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32* ptr = (u32*)mem;</span><br><span class="line">  u32  i   = (MAP_SIZE &gt;&gt; <span class="number">2</span>);</span><br><span class="line">  u32  ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line"></span><br><span class="line">    u32 v = *(ptr++);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!v) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &amp; FF(<span class="number">0</span>)) ret++;</span><br><span class="line">    <span class="keyword">if</span> (v &amp; FF(<span class="number">1</span>)) ret++;</span><br><span class="line">    <span class="keyword">if</span> (v &amp; FF(<span class="number">2</span>)) ret++;</span><br><span class="line">    <span class="keyword">if</span> (v &amp; FF(<span class="number">3</span>)) ret++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Examine map coverage. Called once, for first test case. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_map_coverage</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (count_bytes(trace_bits) &lt; <span class="number">100</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = (<span class="number">1</span> &lt;&lt; (MAP_SIZE_POW2 - <span class="number">1</span>)); i &lt; MAP_SIZE; i++)</span><br><span class="line">    <span class="keyword">if</span> (trace_bits[i]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  WARNF(<span class="string">&quot;Recompile binary with newer version of afl to improve coverage!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 count_bytes 计算 trace_bits 发现的路径数量，如果小于 100 则直接返回</li>
<li>对于 trace_bits 的后半部分，如果有值就返回</li>
<li>否则抛出警告，提示编译新版本的 afl 提高覆盖率</li>
<li>如果是 crash_mode ，则抛出异常（因为没有 crash ）</li>
</ul>
</li>
<li>FAULT_TMOUT<ul>
<li>判断是否设置了 timeout_given （即是否有 -t 参数）<ul>
<li>如果设置了，且 timeout_given 大于 1 ，则抛出警告并设置 q-&gt;cal_failed 为 CAL_CHANCES 且递增 cal_failures</li>
</ul>
</li>
</ul>
</li>
<li>FAULT_CRASH<ul>
<li>如果是 crash_mode ，直接 break 跳出</li>
<li>判断是否设置了 skip_crashes<ul>
<li>如果设置了，则抛出警告并设置 q-&gt;cal_failed 为 CAL_CHANCES 且递增 cal_failures</li>
</ul>
</li>
<li>判断是否设置了 mem_limit<ul>
<li>如果没有设置，则抛出建议增加内存的建议</li>
<li>同时也会打印出一些信息，且抛出测试用例结果 crash 的异常</li>
</ul>
</li>
</ul>
</li>
<li>FAULT_ERROR<ul>
<li>抛出不能执行指定程序的异常</li>
</ul>
</li>
<li>FAULT_NOINST<ul>
<li>抛出没有指令的异常</li>
</ul>
</li>
<li>FAULT_NOBITS<ul>
<li>递增 useless_at_start</li>
<li>如果没有设置 in_bitmap 和 shuffle_queue ，则抛出没有任何新路径的警告</li>
</ul>
</li>
</ul>
</li>
<li>如果有 q-&gt;var_behavior ，则代表它多次运行，在同样的输入条件下出现了不同的覆盖信息，就会抛出这个样例的路径输出可变的警告</li>
<li>随后进行 q→next 的测试，直至结束</li>
</ul>
</li>
<li>遍历结束，如果设置了 cal_failures ，会进行判断：<ul>
<li>如果 cal_failures 等于 queued_paths ，则抛出所有测试用例都超时或 crash 的异常</li>
<li>如果 cal_failures * 5 大于 queued_paths ，则抛出被拒绝的测试用例比例很高的警告</li>
<li>否则打印该阶段的结果</li>
</ul>
</li>
</ul>
<h2 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case"></a>calibrate_case</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Calibrate a new test case. This is done when processing the input directory</span></span><br><span class="line"><span class="comment">   to warn about flaky or otherwise problematic test cases early on; and when</span></span><br><span class="line"><span class="comment">   new paths are discovered to detect variable behavior and so on. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u8 <span class="title function_">calibrate_case</span><span class="params">(<span class="type">char</span>** argv, <span class="keyword">struct</span> queue_entry* q, u8* use_mem,</span></span><br><span class="line"><span class="params">                         u32 handicap, u8 from_queue)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 first_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8  fault = <span class="number">0</span>, new_bits = <span class="number">0</span>, var_detected = <span class="number">0</span>, hnb = <span class="number">0</span>,</span><br><span class="line">      first_run = (q-&gt;exec_cksum == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  u64 start_us, stop_us;</span><br><span class="line"></span><br><span class="line">  s32 old_sc = stage_cur, old_sm = stage_max;</span><br><span class="line">  u32 use_tmout = exec_tmout;</span><br><span class="line">  u8* old_sn = stage_name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Be a bit more generous about timeouts when resuming sessions, or when</span></span><br><span class="line"><span class="comment">     trying to calibrate already-added finds. This helps avoid trouble due</span></span><br><span class="line"><span class="comment">     to intermittent latency. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!from_queue || resuming_fuzz)</span><br><span class="line">    use_tmout = MAX(exec_tmout + CAL_TMOUT_ADD,</span><br><span class="line">                    exec_tmout * CAL_TMOUT_PERC / <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  q-&gt;cal_failed++;</span><br><span class="line"></span><br><span class="line">  stage_name = <span class="string">&quot;calibration&quot;</span>;</span><br><span class="line">  stage_max  = fast_cal ? <span class="number">3</span> : CAL_CYCLES;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure the forkserver is up before we do anything, and let&#x27;s not</span></span><br><span class="line"><span class="comment">     count its spin-up time toward binary calibration. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode != <span class="number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">    init_forkserver(argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line">    hnb = has_new_bits(virgin_bits);</span><br><span class="line">    <span class="keyword">if</span> (hnb &gt; new_bits) new_bits = hnb;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start_us = get_cur_time_us();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 cksum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!first_run &amp;&amp; !(stage_cur % stats_update_freq)) show_stats();</span><br><span class="line"></span><br><span class="line">    write_to_testcase(use_mem, q-&gt;len);</span><br><span class="line"></span><br><span class="line">    fault = run_target(argv, use_tmout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* stop_soon is set by the handler for Ctrl+C. When it&#x27;s pressed,</span></span><br><span class="line"><span class="comment">       we want to bail out quickly. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon || fault != crash_mode) <span class="keyword">goto</span> abort_calibration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !count_bytes(trace_bits)) &#123;</span><br><span class="line">      fault = FAULT_NOINST;</span><br><span class="line">      <span class="keyword">goto</span> abort_calibration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;exec_cksum != cksum) &#123;</span><br><span class="line"></span><br><span class="line">      hnb = has_new_bits(virgin_bits);</span><br><span class="line">      <span class="keyword">if</span> (hnb &gt; new_bits) new_bits = hnb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (q-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        u32 i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i]) &#123;</span><br><span class="line"></span><br><span class="line">            var_bytes[i] = <span class="number">1</span>;</span><br><span class="line">            stage_max    = CAL_CYCLES_LONG;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var_detected = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        q-&gt;exec_cksum = cksum;</span><br><span class="line">        <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop_us = get_cur_time_us();</span><br><span class="line"></span><br><span class="line">  total_cal_us     += stop_us - start_us;</span><br><span class="line">  total_cal_cycles += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* OK, let&#x27;s collect some stats about the performance of this test case.</span></span><br><span class="line"><span class="comment">     This is used for fuzzing air time calculations in calculate_score(). */</span></span><br><span class="line"></span><br><span class="line">  q-&gt;exec_us     = (stop_us - start_us) / stage_max;</span><br><span class="line">  q-&gt;bitmap_size = count_bytes(trace_bits);</span><br><span class="line">  q-&gt;handicap    = handicap;</span><br><span class="line">  q-&gt;cal_failed  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  total_bitmap_size += q-&gt;bitmap_size;</span><br><span class="line">  total_bitmap_entries++;</span><br><span class="line"></span><br><span class="line">  update_bitmap_score(q);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If this case didn&#x27;t result in new output from the instrumentation, tell</span></span><br><span class="line"><span class="comment">     parent. This is a non-critical problem, but something to warn the user</span></span><br><span class="line"><span class="comment">     about. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; first_run &amp;&amp; !fault &amp;&amp; !new_bits) fault = FAULT_NOBITS;</span><br><span class="line"></span><br><span class="line">abort_calibration:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_bits == <span class="number">2</span> &amp;&amp; !q-&gt;has_new_cov) &#123;</span><br><span class="line">    q-&gt;has_new_cov = <span class="number">1</span>;</span><br><span class="line">    queued_with_cov++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark variable paths. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (var_detected) &#123;</span><br><span class="line"></span><br><span class="line">    var_byte_count = count_bytes(var_bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;var_behavior) &#123;</span><br><span class="line">      mark_as_variable(q);</span><br><span class="line">      queued_variable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_name = old_sn;</span><br><span class="line">  stage_cur  = old_sc;</span><br><span class="line">  stage_max  = old_sm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!first_run) show_stats();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要评估测试用例的行为是否异常，并且在发现新路径的时候检测测试用例行为是否可变（也就是同一测试用例出现不同的路径）</p>
<ul>
<li>申请局部变量 first_trace[MAP_SIZE]</li>
<li>如果 q-&gt;exec_cksum 为 0 ，则设置 first_run 为 1</li>
<li>将 stage_cur&#x2F;stage_max&#x2F;stage_name 分别存储在 old_sc&#x2F;old_sm&#x2F;old_sn 中</li>
<li>设置 use_tmout 为 exec_tmout ，如果 from_queue 为 0 或设置了 resuming_fuzz 则代表在恢复会话或尝试校准已添加的结果时，对超时要更加慷慨一些。会将 use_tmout 设成更大的值</li>
<li>递增 q-&gt;cal_failed ，设置 stage_name 为 “calibration” 且通过判断是否设置了 fast_cal 来设置 stage_max 为 3 或 CAL_CYCLES（8）<ul>
<li>stage_max 代表每个测试用例以及显示出可变行为的测试用例的校准周期</li>
</ul>
</li>
<li>如果不是以 dumb mode 运行且没有 no_forkserver （禁用 fork server）和 forksrv_pid 的时候调用 init_forkserver 初始化 fork server</li>
<li>如果设置了 q-&gt;exec_cksum ，则将 trace_bits 拷贝到 first_trace ，并通过 has_new_bits 函数检测 virgin_bits 是否有新的 bits ，如果结果大于 new_bits 则赋值给 new_bits<ul>
<li>q-&gt;exec_cksum 不为空则代表这个 q 不是来自测试用例输入文件夹，而是评估的新的 case</li>
</ul>
</li>
<li>然后开始校准，周期为 stage_max<ul>
<li>如果不是第一次运行且不是 stage_cur % stats_update_freq 的时候，调用 show_stats 函数显示当前状态（运行时间啥的）</li>
<li>调用 write_to_testcase 函数将修改后的数据写入文件进行测试，如果设置了 out_file，则取消链接旧文件并创建一个新文件；否则，out_fd 将被倒带并截断。</li>
<li>调用 run_target 函数运行目标程序并将结果返回到 fault</li>
<li>如果设置了 stop_soon 或 fault 不为 crash_mode 则跳转到 abort_calibration</li>
<li>如果不是 dumb mode 且是校准第一次运行且共享内存中没有任何路径（count_bytes 返回结果为 0 ）则设置 fault 为 FAULT_NOINST 且跳转到 abort_calibration</li>
<li>调用 hash32 函数传入参数 trace_bits 并将结果返回到 cksum ，并且比较 q→cksum 和 cksum<ul>
<li>如果不同，则证明这是第一次运行或同一测试用例出现了不同的路径<ul>
<li>通过 has_new_bits 函数检测 virgin_bits 是否有新的 bits ，如果结果大于 new_bits 则赋值给 new_bits</li>
<li>如果 q→cksum 不为 0 ，则证明同一测试用例出现了不同的路径<ul>
<li>遍历 0 到 MAP_SIZE ，如果 var_bytes[i] 为空且 first_trace[i] 不等于 trace_bits[i] ，则代表发现了不同的路径，将 var_bytes[i] 设为 1 且将 stage_max 设为 CAL_CYCLES_LONG（40），使得评估循环更久</li>
<li>设置 var_detected 为 1</li>
</ul>
</li>
<li>否则 q→cksum 为 0 ，代表是第一次运行<ul>
<li>将 cksum 赋值给 q-&gt;exec_cksum</li>
<li>拷贝 trace_bits 到 first_trace</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>更新 total_cal_us 和 total_cal_cycles</li>
<li>计算一些统计信息<ul>
<li>q-&gt;exec_us ：单次执行时间的平均值</li>
<li>q-&gt;bitmap_size ：count_bytes(trace_bits)，即最后一次执行的覆盖路径数</li>
<li>q-&gt;handicap ：handicap</li>
<li>q-&gt;cal_failed ：0</li>
<li>total_bitmap_size ：添加 q-&gt;bitmap_size 的数目</li>
<li>递增 total_bitmap_entries</li>
<li>调用 update_bitmap_score 来为该测试用例寻找一组最小的路径来触发到目前为止在位图中看到的所有位，并专注于以牺牲其余部分为代价来模糊它们。</li>
</ul>
</li>
<li>如果不是 dumb mode 且不是第一次运行且没有设置 fault 且没有设置 new_bits ，代表该测试用例在所有轮次的执行里都没有发现任何新的路径和异常，则设置 fault 为 FAULT_NOBITS</li>
<li>接下来是 abort_calibration 的 label 处<ul>
<li>如果 new_bits 为 2 且 q-&gt;has_new_cov 为 0 ，则设置 q-&gt;has_new_cov 为 1 且递增 queued_with_cov ，代表发现了新的路径</li>
<li>如果设置了 var_detected （该测试用例运行多次有多个路径）<ul>
<li>将 count_bytes(var_bytes) 的结果赋值给 var_byte_count ，也就是统计可变路径的数目</li>
<li>如果没有设置 q-&gt;var_behavior<ul>
<li>调用 mark_as_variable 函数为该测试用例创建符号链接，..&#x2F;..&#x2F;xxx → out_dir&#x2F;&#x2F;queue&#x2F;.state&#x2F;variable_behavior&#x2F;xxx 的文件，并将 q-&gt;var_behavior 设置为 1</li>
<li>递增 queued_variable</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>从 old_sc&#x2F;old_sm&#x2F;old_sn 中恢复 stage_cur&#x2F;stage_max&#x2F;stage_name</li>
<li>如果不是第一次运行，调用 show_stats 显示状态</li>
<li>最后返回 fault 值</li>
</ul>
<h2 id="init-forkserver"><a href="#init-forkserver" class="headerlink" title="init_forkserver"></a>init_forkserver</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Spin up fork server (instrumented mode only). The idea is explained here:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   In essence, the instrumentation allows us to skip execve(), and just keep</span></span><br><span class="line"><span class="comment">   cloning a stopped child. So, we just execute once, and then send commands</span></span><br><span class="line"><span class="comment">   through a pipe. The other part of this logic is in afl-as.h. */</span></span><br><span class="line"></span><br><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">init_forkserver</span><span class="params">(<span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="type">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  s32 rlen;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Spinning up the fork server...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pipe(st_pipe) || pipe(ctl_pipe)) PFATAL(<span class="string">&quot;pipe() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  forksrv_pid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (forksrv_pid &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!forksrv_pid) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Umpf. On OpenBSD, the default fd limit for root users is set to</span></span><br><span class="line"><span class="comment">       soft 128. Let&#x27;s try to fix that... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!getrlimit(RLIMIT_NOFILE, &amp;r) &amp;&amp; r.rlim_cur &lt; FORKSRV_FD + <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">      r.rlim_cur = FORKSRV_FD + <span class="number">2</span>;</span><br><span class="line">      setrlimit(RLIMIT_NOFILE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_limit) &#123;</span><br><span class="line"></span><br><span class="line">      r.rlim_max = r.rlim_cur = ((<span class="type">rlim_t</span>)mem_limit) &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line"></span><br><span class="line">      setrlimit(RLIMIT_AS, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* This takes care of OpenBSD, which doesn&#x27;t have RLIMIT_AS, but</span></span><br><span class="line"><span class="comment">         according to reliable sources, RLIMIT_DATA covers anonymous</span></span><br><span class="line"><span class="comment">         maps - so we should be getting good protection against OOM bugs. */</span></span><br><span class="line"></span><br><span class="line">      setrlimit(RLIMIT_DATA, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dumping cores is slow and can lead to anomalies if SIGKILL is delivered</span></span><br><span class="line"><span class="comment">       before the dump is complete. */</span></span><br><span class="line"></span><br><span class="line">    r.rlim_max = r.rlim_cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    setrlimit(RLIMIT_CORE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Isolate the process and configure standard descriptors. If out_file is</span></span><br><span class="line"><span class="comment">       specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span></span><br><span class="line"></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    dup2(dev_null_fd, <span class="number">1</span>);</span><br><span class="line">    dup2(dev_null_fd, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (out_file) &#123;</span><br><span class="line"></span><br><span class="line">      dup2(dev_null_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      dup2(out_fd, <span class="number">0</span>);</span><br><span class="line">      close(out_fd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up control and status pipes, close the unneeded original fds. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dup2(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dup2(st_pipe[<span class="number">1</span>], FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">    close(ctl_pipe[<span class="number">1</span>]);</span><br><span class="line">    close(st_pipe[<span class="number">0</span>]);</span><br><span class="line">    close(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    close(out_dir_fd);</span><br><span class="line">    close(dev_null_fd);</span><br><span class="line">    close(dev_urandom_fd);</span><br><span class="line">    close(fileno(plot_file));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This should improve performance a bit, since it stops the linker from</span></span><br><span class="line"><span class="comment">       doing extra work post-fork(). */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!getenv(<span class="string">&quot;LD_BIND_LAZY&quot;</span>)) setenv(<span class="string">&quot;LD_BIND_NOW&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set sane defaults for ASAN if nothing else specified. */</span></span><br><span class="line"></span><br><span class="line">    setenv(<span class="string">&quot;ASAN_OPTIONS&quot;</span>, <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                           <span class="string">&quot;detect_leaks=0:&quot;</span></span><br><span class="line">                           <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                           <span class="string">&quot;allocator_may_return_null=1&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MSAN is tricky, because it doesn&#x27;t support abort_on_error=1 at this</span></span><br><span class="line"><span class="comment">       point. So, we do this in a very hacky way. */</span></span><br><span class="line"></span><br><span class="line">    setenv(<span class="string">&quot;MSAN_OPTIONS&quot;</span>, <span class="string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="string">&quot;:&quot;</span></span><br><span class="line">                           <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                           <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                           <span class="string">&quot;allocator_may_return_null=1:&quot;</span></span><br><span class="line">                           <span class="string">&quot;msan_track_origins=0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    execv(target_path, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use a distinctive bitmap signature to tell the parent about execv()</span></span><br><span class="line"><span class="comment">       falling through. */</span></span><br><span class="line"></span><br><span class="line">    *(u32*)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Close the unneeded endpoints. */</span></span><br><span class="line"></span><br><span class="line">  close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">  close(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];</span><br><span class="line">  fsrv_st_fd  = st_pipe[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wait for the fork server to come up, but don&#x27;t wait too long. */</span></span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / <span class="number">1000</span>);</span><br><span class="line">  it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  rlen = read(fsrv_st_fd, &amp;status, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">  it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">     Otherwise, try to figure out what went wrong. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123;</span><br><span class="line">    OKF(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child_timed_out)</span><br><span class="line">    FATAL(<span class="string">&quot;Timeout while initializing fork server (adjusting -t may help)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (waitpid(forksrv_pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="number">500</span> &amp;&amp; uses_asan) &#123;</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    from the fuzzer! Since it seems to be built with ASAN and you have a\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    restrictive memory limit configured, this is expected; please read\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    %s/notes_for_asan.txt for help.\n&quot;</span>, doc_path);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mem_limit) &#123;</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - The current memory limit (%s) is too restrictive, causing the\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      target to hit an OOM condition in the dynamic linker. Try bumping up\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      the limit with the -m setting in the command line. A simple way confirm\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      this diagnosis would be:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">           <span class="string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">           <span class="string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,</span><br><span class="line">           DMS(mem_limit &lt;&lt; <span class="number">20</span>), mem_limit - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FATAL(<span class="string">&quot;Fork server crashed with signal %d&quot;</span>, WTERMSIG(status));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*(u32*)trace_bits == EXEC_FAIL_SIG)</span><br><span class="line">    FATAL(<span class="string">&quot;Unable to execute target application (&#x27;%s&#x27;)&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="number">500</span> &amp;&amp; uses_asan) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    handshake with the injected code. Since it seems to be built with ASAN and\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    you have a restrictive memory limit configured, this is expected; please\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    read %s/notes_for_asan.txt for help.\n&quot;</span>, doc_path);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mem_limit) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    handshake with the injected code. Perhaps there is a horrible bug in the\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    fuzzer. Poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    handshake with the injected code. There are %s probable explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;%s&quot;</span></span><br><span class="line">         <span class="string">&quot;    - The current memory limit (%s) is too restrictive, causing an OOM\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      fault in the dynamic linker. This can be fixed with the -m option. A\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      simple way to confirm the diagnosis may be:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">         <span class="string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">         <span class="string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,</span><br><span class="line">         getenv(DEFER_ENV_VAR) ? <span class="string">&quot;three&quot;</span> : <span class="string">&quot;two&quot;</span>,</span><br><span class="line">         getenv(DEFER_ENV_VAR) ?</span><br><span class="line">         <span class="string">&quot;    - You are using deferred forkserver, but __AFL_INIT() is never\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      reached before the program terminates.\n\n&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">         DMS(mem_limit &lt;&lt; <span class="number">20</span>), mem_limit - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Fork server handshake failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化 st_pipe 和 ctl_pipe 管道<ul>
<li>st_pipe 为状态管道</li>
<li>ctl_pipe 为控制管道</li>
</ul>
</li>
<li>调用 fork 弄出来子进程并将返回的 pid 赋值给 forksrv_pid</li>
<li>子进程会执行以下操作<ul>
<li>设置一些 fd limit</li>
<li>调用 setsid 方法创建新的会话</li>
<li>关闭 stdout 和 stderr</li>
<li>如果定义了 out_file ，关闭 stdin ；否则关闭 out_fd</li>
<li>将 FORKSRV_FD 重定向到 ctl_pipe[0] ，FORKSRV_FD + 1 重定向到 st_pipe[1]<ul>
<li>此时子进程只能从控制管道读，向状态管道写</li>
</ul>
</li>
<li>关闭描述符<ul>
<li>st_pipe&#x2F;ctl_pipe&#x2F;out_dir_fd&#x2F;dev_null_fd&#x2F;dev_urandom_fd&#x2F;fileno(plot_file)</li>
</ul>
</li>
<li>从环境变量中读取 LD_BIND_LAZY ，如果没有则设置 LD_BIND_NOW 为 1 ，防止linker在fork之后做额外的工作</li>
<li>设置 ASAN_OPTIONS 和 MSAN_OPTIONS 环境变量</li>
<li>启动 <strong>execv(target_path, argv)</strong></li>
<li>如果启动失败，设置 trace_bits 为 EXEC_FAIL_SIG 告诉父进程并退出子进程</li>
</ul>
</li>
<li>父进程会执行以下操作<ul>
<li>关闭 ctl_pipe[0] 和 st_pipe[1]</li>
<li>将 ctl_pipe[1] 赋值给 fsrv_ctl_fd ，st_pipe[0] 赋值给 fsrv_st_fd</li>
<li>等待 forkserver 启动</li>
<li>从 fsrv_st_fd 读取 4 字节的状态信息<ul>
<li>如果读取到了，直接返回</li>
<li>如果设置 child_timed_out 了，抛出异常告诉用户设置 -t 选项</li>
<li>等待 waitpid(forksrv_pid, &amp;status, 0) 返回，如果小于 0 抛出异常</li>
<li>调用 WIFSIGNALED 判断返回的 status 是否为异常退出的信号<ul>
<li>如果是，则<ul>
<li>判断是否设置了 mem_limit 且 mem_limit 小于 500 且设置了 uses_asan<ul>
<li>告知用户是由于未收到任何 input 就 crash ，可能是由于 asan 和 mem_limit 的原因。查看 notes_for_asan.txt 。</li>
<li>如果没有设置 mem_limit ，告知用户可能的原因</li>
<li>否则告知用户其他的原因</li>
</ul>
</li>
</ul>
</li>
<li>如果否，则<ul>
<li>判断 trace_bits 是否等于 EXEC_FAIL_SIG ，如果是则子进程的 execve 没有正常执行</li>
<li>接下来的判断和是的情况一样，也是告知用户可能的原因</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="has-new-bits"><a href="#has-new-bits" class="headerlink" title="has_new_bits"></a>has_new_bits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if the current execution path brings anything new to the table.</span></span><br><span class="line"><span class="comment">   Update virgin bits to reflect the finds. Returns 1 if the only change is</span></span><br><span class="line"><span class="comment">   the hit-count for a particular tuple; 2 if there are new tuples seen. </span></span><br><span class="line"><span class="comment">   Updates the map, so subsequent calls will always return 0.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is called after every exec() on a fairly large buffer, so</span></span><br><span class="line"><span class="comment">   it needs to be fast. We do this in 32-bit and 64-bit flavors. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u8 <span class="title function_">has_new_bits</span><span class="params">(u8* virgin_map)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"></span><br><span class="line">  u64* current = (u64*)trace_bits;</span><br><span class="line">  u64* virgin  = (u64*)virgin_map;</span><br><span class="line"></span><br><span class="line">  u32  i = (MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  u32* current = (u32*)trace_bits;</span><br><span class="line">  u32* virgin  = (u32*)virgin_map;</span><br><span class="line"></span><br><span class="line">  u32  i = (MAP_SIZE &gt;&gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">  u8   ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize for (*current &amp; *virgin) == 0 - i.e., no bits in current bitmap</span></span><br><span class="line"><span class="comment">       that have not been already cleared from the virgin map - since this will</span></span><br><span class="line"><span class="comment">       almost always be the case. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*current) &amp;&amp; unlikely(*current &amp; *virgin)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (likely(ret &lt; <span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        u8* cur = (u8*)current;</span><br><span class="line">        u8* vir = (u8*)virgin;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Looks like we have not found any new bytes yet; see if any non-zero</span></span><br><span class="line"><span class="comment">           bytes in current[] are pristine in virgin[]. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">4</span>] &amp;&amp; vir[<span class="number">4</span>] == <span class="number">0xff</span>) || (cur[<span class="number">5</span>] &amp;&amp; vir[<span class="number">5</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">6</span>] &amp;&amp; vir[<span class="number">6</span>] == <span class="number">0xff</span>) || (cur[<span class="number">7</span>] &amp;&amp; vir[<span class="number">7</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      *virgin &amp;= ~*current;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current++;</span><br><span class="line">    virgin++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret &amp;&amp; virgin_map == virgin_bits) bitmap_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置参数 current 和 virgin 分别为 trace_bits 和 virgin_map ，同时根据 64 还是 32 位设置 i 为 MAP_SIZE &gt;&gt;3 或 MAP_SIZE &gt;&gt; 2 ，并初始化 ret 为 0</li>
<li>8 字节一组挨个遍历 map<ul>
<li>如果 *current 不为 0 且 *current &amp; *virgin 不为 0 ，则代表发现了新的路径或路径的执行次数发生了变化<ul>
<li>如果 ret &lt; 2<ul>
<li>判断 current 和 virgin 中是否存在 cur[i] &amp;&amp; vir[i] &#x3D;&#x3D; 0xff ，0 &lt; i &lt; 7<ul>
<li>如果有一个为真，则设置 ret 为 2 ，也就是发现了新的路径<ul>
<li>vir[i] &#x3D;&#x3D; 0xff 表示之前都为覆盖该路径，而 cur[i] 则表示这次覆盖到了</li>
</ul>
</li>
<li>否则设置 ret 为 1 ，也就是路径的执行次数发生了变化</li>
</ul>
</li>
</ul>
</li>
<li>设置 virgin &amp;&#x3D; ~*current</li>
</ul>
</li>
</ul>
</li>
<li>如果 ret 不为 0 且 virgin_map 等于 virgin_bits ，则设置 bitmap_changed 为 1<ul>
<li>virgin_bits 保存还没有被 Fuzz 覆盖到的 byte ，其初始值每位全被置位 1 ，然后每次按字节置位</li>
</ul>
</li>
</ul>
<h2 id="run-target"><a href="#run-target" class="headerlink" title="run_target"></a><strong><strong>run_target</strong></strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Execute target application, monitoring for timeouts. Return status</span></span><br><span class="line"><span class="comment">   information. The called program will update trace_bits[]. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u8 <span class="title function_">run_target</span><span class="params">(<span class="type">char</span>** argv, u32 timeout)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="type">static</span> u32 prev_timed_out = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> u64 exec_ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">  u32 tb4;</span><br><span class="line"></span><br><span class="line">  child_timed_out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* After this memset, trace_bits[] are effectively volatile, so we</span></span><br><span class="line"><span class="comment">     must prevent any earlier operations from venturing into that</span></span><br><span class="line"><span class="comment">     territory. */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">  MEM_BARRIER();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we&#x27;re running in &quot;dumb&quot; mode, we can&#x27;t rely on the fork server</span></span><br><span class="line"><span class="comment">     logic compiled into the target program, so we will just keep calling</span></span><br><span class="line"><span class="comment">     execve(). There is a bit of code duplication between here and </span></span><br><span class="line"><span class="comment">     init_forkserver(), but c&#x27;est la vie. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_forkserver) &#123;</span><br><span class="line"></span><br><span class="line">    child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!child_pid) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mem_limit) &#123;</span><br><span class="line"></span><br><span class="line">        r.rlim_max = r.rlim_cur = ((<span class="type">rlim_t</span>)mem_limit) &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line"></span><br><span class="line">        setrlimit(RLIMIT_AS, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        setrlimit(RLIMIT_DATA, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      r.rlim_max = r.rlim_cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      setrlimit(RLIMIT_CORE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Isolate the process and configure standard descriptors. If out_file is</span></span><br><span class="line"><span class="comment">         specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span></span><br><span class="line"></span><br><span class="line">      setsid();</span><br><span class="line"></span><br><span class="line">      dup2(dev_null_fd, <span class="number">1</span>);</span><br><span class="line">      dup2(dev_null_fd, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (out_file) &#123;</span><br><span class="line"></span><br><span class="line">        dup2(dev_null_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        dup2(out_fd, <span class="number">0</span>);</span><br><span class="line">        close(out_fd);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* On Linux, would be faster to use O_CLOEXEC. Maybe TODO. */</span></span><br><span class="line"></span><br><span class="line">      close(dev_null_fd);</span><br><span class="line">      close(out_dir_fd);</span><br><span class="line">      close(dev_urandom_fd);</span><br><span class="line">      close(fileno(plot_file));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Set sane defaults for ASAN if nothing else specified. */</span></span><br><span class="line"></span><br><span class="line">      setenv(<span class="string">&quot;ASAN_OPTIONS&quot;</span>, <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                             <span class="string">&quot;detect_leaks=0:&quot;</span></span><br><span class="line">                             <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                             <span class="string">&quot;allocator_may_return_null=1&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      setenv(<span class="string">&quot;MSAN_OPTIONS&quot;</span>, <span class="string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="string">&quot;:&quot;</span></span><br><span class="line">                             <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                             <span class="string">&quot;msan_track_origins=0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      execv(target_path, argv);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Use a distinctive bitmap value to tell the parent about execv()</span></span><br><span class="line"><span class="comment">         falling through. */</span></span><br><span class="line"></span><br><span class="line">      *(u32*)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    s32 res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In non-dumb mode, we have the fork server up and running, so simply</span></span><br><span class="line"><span class="comment">       tell it to have at it, and then read back PID. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;child_pid, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt;= <span class="number">0</span>) FATAL(<span class="string">&quot;Fork server is misbehaving (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure timeout, as requested by user, then wait for child to terminate. */</span></span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = (timeout / <span class="number">1000</span>);</span><br><span class="line">  it.it_value.tv_usec = (timeout % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The SIGALRM handler simply kills the child_pid and sets child_timed_out. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_forkserver) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waitpid(child_pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    s32 res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;status, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      RPFATAL(res, <span class="string">&quot;Unable to communicate with fork server (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!WIFSTOPPED(status)) child_pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  getitimer(ITIMER_REAL, &amp;it);</span><br><span class="line">  exec_ms = (u64) timeout - (it.it_value.tv_sec * <span class="number">1000</span> +</span><br><span class="line">                             it.it_value.tv_usec / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">  it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  total_execs++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Any subsequent operations on trace_bits must not be moved by the</span></span><br><span class="line"><span class="comment">     compiler below this point. Past this location, trace_bits[] behave</span></span><br><span class="line"><span class="comment">     very normally and do not have to be treated as volatile. */</span></span><br><span class="line"></span><br><span class="line">  MEM_BARRIER();</span><br><span class="line"></span><br><span class="line">  tb4 = *(u32*)trace_bits;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">  classify_counts((u64*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  classify_counts((u32*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">  prev_timed_out = child_timed_out;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Report outcome to caller. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123;</span><br><span class="line"></span><br><span class="line">    kill_signal = WTERMSIG(status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_timed_out &amp;&amp; kill_signal == SIGKILL) <span class="keyword">return</span> FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* A somewhat nasty hack for MSAN, which doesn&#x27;t support abort_on_error and</span></span><br><span class="line"><span class="comment">     must use a special exit code. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uses_asan &amp;&amp; WEXITSTATUS(status) == MSAN_ERROR) &#123;</span><br><span class="line">    kill_signal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((dumb_mode == <span class="number">1</span> || no_forkserver) &amp;&amp; tb4 == EXEC_FAIL_SIG)</span><br><span class="line">    <span class="keyword">return</span> FAULT_ERROR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* It makes sense to account for the slowest units only if the testcase was run</span></span><br><span class="line"><span class="comment">  under the user defined timeout. */</span></span><br><span class="line">  <span class="keyword">if</span> (!(timeout &gt; exec_tmout) &amp;&amp; (slowest_exec_ms &lt; exec_ms)) &#123;</span><br><span class="line">    slowest_exec_ms = exec_ms;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FAULT_NONE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>清空 trace_bits</p>
</li>
<li><p>如果 dumb_mode 为 1 或 no_forkserver 为 1 ，则执行一段与 init_forkserver 中类似的操作，会 fork 出子进程并进行类似的操作</p>
</li>
<li><p>否则向 fsrv_ctl_fd 写入 prev_timed_out 的值，写入失败且设置了 stop_soon 则直接抛出错误</p>
</li>
<li><p>从 fsrv_st_fd 中读取 child_pid 的值，读取失败且设置了 stop_soon 则直接抛出错误</p>
</li>
<li><p>如果 child_pid 小于 0 则直接抛出错误</p>
</li>
<li><p>设置 timer</p>
</li>
<li><p>如果 dumb_mode 为 1 或 no_forkserver 为 1 ，那就 waitpid(child_pid, &amp;status, 0) ，返回为负数则抛出异常</p>
</li>
<li><p>否则再次从 fsrv_st_fd 中读取 child_pid 的值，读取失败且设置了 stop_soon 则直接抛出错误</p>
</li>
<li><p>如果 WIFSTOPPED(status) 为 0 ，则设置 child_pid 为 0</p>
</li>
<li><p>自增 total_execs</p>
</li>
<li><p>调用 classify_counts(trace_bits)，对 trace_bits 进行规整化</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">classify_counts</span><span class="params">(u64* mem)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 i = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize for sparse bitmaps. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*mem)) &#123;</span><br><span class="line"></span><br><span class="line">      u16* mem16 = (u16*)mem;</span><br><span class="line"></span><br><span class="line">      mem16[<span class="number">0</span>] = count_class_lookup16[mem16[<span class="number">0</span>]];</span><br><span class="line">      mem16[<span class="number">1</span>] = count_class_lookup16[mem16[<span class="number">1</span>]];</span><br><span class="line">      mem16[<span class="number">2</span>] = count_class_lookup16[mem16[<span class="number">2</span>]];</span><br><span class="line">      mem16[<span class="number">3</span>] = count_class_lookup16[mem16[<span class="number">3</span>]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mem++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">classify_counts</span><span class="params">(u32* mem)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 i = MAP_SIZE &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize for sparse bitmaps. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*mem)) &#123;</span><br><span class="line"></span><br><span class="line">      u16* mem16 = (u16*)mem;</span><br><span class="line"></span><br><span class="line">      mem16[<span class="number">0</span>] = count_class_lookup16[mem16[<span class="number">0</span>]];</span><br><span class="line">      mem16[<span class="number">1</span>] = count_class_lookup16[mem16[<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mem++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 prev_timed_out 为 child_timed_out</p>
</li>
<li><p>若 WIFSIGNALED(status) 为真（异常退出）且没有设置 stop_soon</p>
<ul>
<li>使用 WTERMSIG 获得 status 的 kill_signal</li>
<li>如果设置了 child_timed_out 且 kill_signal 为 SIGKILL 则返回 FAULT_TMOUT</li>
<li>否则返回 FAULT_CRASH</li>
</ul>
</li>
<li><p>如果设置了 uses_asan 且 WEXITSTATUS(status) 为 MSAN_ERROR</p>
<ul>
<li>清空 kill_signal</li>
<li>返回 FAULT_CRASH</li>
</ul>
</li>
<li><p>如果 dumb_mode 为 1 或设置了 no_forkserver 且未规整化之前的 trace_bits 为 EXEC_FAIL_SIG</p>
<ul>
<li>返回 FAULT_ERROR</li>
</ul>
</li>
<li><p>如果 timeout 不小于 exec_tmout 且 slowest_exec_ms 小于 exec_ms</p>
<ul>
<li>设置 slowest_exec_ms 为 exec_ms</li>
</ul>
</li>
<li><p>最后返回 FAULT_NONE</p>
</li>
</ul>
<h2 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score"></a><strong><strong>update_bitmap_score</strong></strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* When we bump into a new path, we call this to see if the path appears</span></span><br><span class="line"><span class="comment">   more &quot;favorable&quot; than any of the existing ones. The purpose of the</span></span><br><span class="line"><span class="comment">   &quot;favorables&quot; is to have a minimal set of paths that trigger all the bits</span></span><br><span class="line"><span class="comment">   seen in the bitmap so far, and focus on fuzzing them at the expense of</span></span><br><span class="line"><span class="comment">   the rest.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The first step of the process is to maintain a list of top_rated[] entries</span></span><br><span class="line"><span class="comment">   for every byte in the bitmap. We win that slot if there is no previous</span></span><br><span class="line"><span class="comment">   contender, or if the contender has a more favorable speed x size factor. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_bitmap_score</span><span class="params">(<span class="keyword">struct</span> queue_entry* q)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line">  u64 fav_factor = q-&gt;exec_us * q-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* For every byte set in trace_bits[], see if there is a previous winner,</span></span><br><span class="line"><span class="comment">     and how it compares to us. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trace_bits[i]) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (top_rated[i]) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Faster-executing or smaller test cases are favored. */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Looks like we&#x27;re going to win. Decrease ref count for the</span></span><br><span class="line"><span class="comment">            previous winner, discard its trace_bits[] if necessary. */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!--top_rated[i]-&gt;tc_ref) &#123;</span><br><span class="line">           ck_free(top_rated[i]-&gt;trace_mini);</span><br><span class="line">           top_rated[i]-&gt;trace_mini = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Insert ourselves as the new winner. */</span></span><br><span class="line"></span><br><span class="line">       top_rated[i] = q;</span><br><span class="line">       q-&gt;tc_ref++;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!q-&gt;trace_mini) &#123;</span><br><span class="line">         q-&gt;trace_mini = ck_alloc(MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">         minimize_bits(q-&gt;trace_mini, trace_bits);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       score_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当我们发现新的路径，都会调用该函数来判断其是不是更加 favorable 的，也就是说是否包含最小的路径集合来遍历到所有 bitmap 中的位</p>
<ul>
<li>首先计算 fav_factor &#x3D; q-&gt;exec_us * q-&gt;len</li>
<li>遍历 MAP_SIZE 大小<ul>
<li>如果 trace_bits[i] 不为 0 ，则表示这是已经被覆盖到的 path<ul>
<li>如果 top_rated[i] 不为 0 ，则  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>*</span></span><br><span class="line"><span class="class">  <span class="title">top_rated</span>[<span class="title">MAP_SIZE</span>];</span>                <span class="comment">/* Top entries for bitmap bytes     */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>判断 fav_factor 是否大于 top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len ，是的话代表 top_rated 更优，就 continue<ul>
<li>执行时间和样例大小的乘积</li>
</ul>
</li>
<li>否则 q 更小，则将 top_rated[i]-&gt;tc_ref 减一，如果减一之后的值为 0 则 free 掉 top_rated[i]-&gt;trace_mini 并清空</li>
</ul>
</li>
<li>将 top_rated[i] 赋值为 q 并递增 q-&gt;tc_ref</li>
<li>如果没有初始化 q-&gt;trace_mini 则 alloc(MAP_SIZE &gt;&gt; 3) 并调用 minimize_bits(q-&gt;trace_mini, trace_bits)  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compact trace bytes into a smaller bitmap. We effectively just drop the</span></span><br><span class="line"><span class="comment">   count information here. This is called only sporadically, for some</span></span><br><span class="line"><span class="comment">   new paths. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">minimize_bits</span><span class="params">(u8* dst, u8* src)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; MAP_SIZE) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(src++)) dst[i &gt;&gt; <span class="number">3</span>] |= <span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>);</span><br><span class="line">    i++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将 trace_bits 压缩为较小的位图，byte → bit 的映射</li>
</ul>
</li>
<li>将 score_changed 置为 1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue"></a>cull_queue</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The second part of the mechanism discussed above is a routine that</span></span><br><span class="line"><span class="comment">   goes over top_rated[] entries, and then sequentially grabs winners for</span></span><br><span class="line"><span class="comment">   previously-unseen bytes (temp_v) and marks them as favored, at least</span></span><br><span class="line"><span class="comment">   until the next run. The favored entries are given more air time during</span></span><br><span class="line"><span class="comment">   all fuzzing steps. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cull_queue</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span>;</span></span><br><span class="line">  <span class="type">static</span> u8 temp_v[MAP_SIZE &gt;&gt; <span class="number">3</span>];</span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode || !score_changed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  score_changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(temp_v, <span class="number">255</span>, MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  queued_favored  = <span class="number">0</span>;</span><br><span class="line">  pending_favored = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  q = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    q-&gt;favored = <span class="number">0</span>;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s see if anything in the bitmap isn&#x27;t captured in temp_v.</span></span><br><span class="line"><span class="comment">     If yes, and if it has a top_rated[] contender, let&#x27;s use it. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">    <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>)))) &#123;</span><br><span class="line"></span><br><span class="line">      u32 j = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Remove all bits belonging to the current entry from temp_v. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (j--) </span><br><span class="line">        <span class="keyword">if</span> (top_rated[i]-&gt;trace_mini[j])</span><br><span class="line">          temp_v[j] &amp;= ~top_rated[i]-&gt;trace_mini[j];</span><br><span class="line"></span><br><span class="line">      top_rated[i]-&gt;favored = <span class="number">1</span>;</span><br><span class="line">      queued_favored++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!top_rated[i]-&gt;was_fuzzed) pending_favored++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  q = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    mark_as_redundant(q, !q-&gt;favored);</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>精简队列的函数</p>
<ul>
<li>初始化 queue_entry* q 和 u8 temp_v[MAP_SIZE &gt;&gt; 3] 以及 i</li>
<li>如果设置了 dumb_mode  或没有设置 score_changed 则返回</li>
<li>初始化 score_changed&#x2F;queued_favored&#x2F;pending_favored  为 0 且清空 temp_v</li>
<li>将 queue 赋值给 q ，遍历 q 链表将 favored 都置为 0</li>
<li>从 0 开始遍历 i 直到 MAP_SIZE<ul>
<li>如果 top_rated[i] 存在且 (temp_v[i &gt;&gt; 3] &amp; (1 &lt;&lt; (i &amp; 7))) 为 1（也就是判断该 path 对应的 bit 有没有被置位）<ul>
<li>设置 j 为 MAP_SIZE &gt;&gt; 3</li>
<li>递减 j<ul>
<li>如果存在 top_rated[i]-&gt;trace_mini[j] 则设置 temp_v[j] &amp;&#x3D; ~top_rated[i]-&gt;trace_mini[j]</li>
<li>设置 top_rated[i]-&gt;favored 为 1</li>
<li>递增 queued_favored</li>
</ul>
</li>
<li>如果 top_rated[i]-&gt;was_fuzzed 为 0 ，则递增 pending_favored</li>
</ul>
</li>
<li>将 queue 赋值给 q</li>
<li>遍历 q 链表，调用 mark_as_redundant(q, !q-&gt;favored)</li>
</ul>
</li>
<li>上面的遍历是为了找出一组能够覆盖到所有现在已经覆盖到的路径的 queue entry</li>
</ul>
<h2 id="mark-as-redundant"><a href="#mark-as-redundant" class="headerlink" title="mark_as_redundant"></a>mark_as_redundant</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Mark / unmark as redundant (edge-only). This is not used for restoring state,</span></span><br><span class="line"><span class="comment">   but may be useful for post-processing datasets. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mark_as_redundant</span><span class="params">(<span class="keyword">struct</span> queue_entry* q, u8 state)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8* fn;</span><br><span class="line">  s32 fd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state == q-&gt;fs_redundant) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  q-&gt;fs_redundant = state;</span><br><span class="line"></span><br><span class="line">  fn = <span class="built_in">strrchr</span>(q-&gt;fname, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/queue/.state/redundant_edges/%s&quot;</span>, out_dir, fn + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state) &#123;</span><br><span class="line"></span><br><span class="line">    fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlink(fn)) PFATAL(<span class="string">&quot;Unable to remove &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断 q-&gt;fs_redundant 是否等于 state ，是的话则返回</li>
<li>否则设置 q-&gt;fs_redundant 为 state</li>
<li>如果 state 为 1 ，尝试创建 out_dir&#x2F;queue&#x2F;.state&#x2F;redundant_edges&#x2F;fname</li>
<li>否则 state 为 0 ，尝试删除 out_dir&#x2F;queue&#x2F;.state&#x2F;redundant_edges&#x2F;fname</li>
</ul>
<h2 id="show-init-stats"><a href="#show-init-stats" class="headerlink" title="show_init_stats"></a><strong><strong>show_init_stats</strong></strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Display quick statistics at the end of processing the input directory,</span></span><br><span class="line"><span class="comment">   plus a bunch of warnings. Some calibration stuff also ended up here,</span></span><br><span class="line"><span class="comment">   along with several hardcoded constants. Maybe clean up eventually. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_init_stats</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> =</span> <span class="built_in">queue</span>;</span><br><span class="line">  u32 min_bits = <span class="number">0</span>, max_bits = <span class="number">0</span>;</span><br><span class="line">  u64 min_us = <span class="number">0</span>, max_us = <span class="number">0</span>;</span><br><span class="line">  u64 avg_us = <span class="number">0</span>;</span><br><span class="line">  u32 max_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (total_cal_cycles) avg_us = total_cal_us / total_cal_cycles;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!min_us || q-&gt;exec_us &lt; min_us) min_us = q-&gt;exec_us;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;exec_us &gt; max_us) max_us = q-&gt;exec_us;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!min_bits || q-&gt;bitmap_size &lt; min_bits) min_bits = q-&gt;bitmap_size;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;bitmap_size &gt; max_bits) max_bits = q-&gt;bitmap_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;len &gt; max_len) max_len = q-&gt;len;</span><br><span class="line"></span><br><span class="line">    q = q-&gt;next;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SAYF(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (avg_us &gt; (qemu_mode ? <span class="number">50000</span> : <span class="number">10000</span>)) </span><br><span class="line">    WARNF(cLRD <span class="string">&quot;The target binary is pretty slow! See %s/perf_tips.txt.&quot;</span>,</span><br><span class="line">          doc_path);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s keep things moving with slow binaries. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (avg_us &gt; <span class="number">50000</span>) havoc_div = <span class="number">10</span>;     <span class="comment">/* 0-19 execs/sec   */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (avg_us &gt; <span class="number">20000</span>) havoc_div = <span class="number">5</span>; <span class="comment">/* 20-49 execs/sec  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (avg_us &gt; <span class="number">10000</span>) havoc_div = <span class="number">2</span>; <span class="comment">/* 50-100 execs/sec */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!resuming_fuzz) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (max_len &gt; <span class="number">50</span> * <span class="number">1024</span>)</span><br><span class="line">      WARNF(cLRD <span class="string">&quot;Some test cases are huge (%s) - see %s/perf_tips.txt!&quot;</span>,</span><br><span class="line">            DMS(max_len), doc_path);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (max_len &gt; <span class="number">10</span> * <span class="number">1024</span>)</span><br><span class="line">      WARNF(<span class="string">&quot;Some test cases are big (%s) - see %s/perf_tips.txt.&quot;</span>,</span><br><span class="line">            DMS(max_len), doc_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useless_at_start &amp;&amp; !in_bitmap)</span><br><span class="line">      WARNF(cLRD <span class="string">&quot;Some test cases look useless. Consider using a smaller set.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queued_paths &gt; <span class="number">100</span>)</span><br><span class="line">      WARNF(cLRD <span class="string">&quot;You probably have far too many input files! Consider trimming down.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (queued_paths &gt; <span class="number">20</span>)</span><br><span class="line">      WARNF(<span class="string">&quot;You have lots of input files; try starting small.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;Here are some useful stats:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">      cGRA <span class="string">&quot;    Test case count : &quot;</span> cRST <span class="string">&quot;%u favored, %u variable, %u total\n&quot;</span></span><br><span class="line">      cGRA <span class="string">&quot;       Bitmap range : &quot;</span> cRST <span class="string">&quot;%u to %u bits (average: %0.02f bits)\n&quot;</span></span><br><span class="line">      cGRA <span class="string">&quot;        Exec timing : &quot;</span> cRST <span class="string">&quot;%s to %s us (average: %s us)\n&quot;</span>,</span><br><span class="line">      queued_favored, queued_variable, queued_paths, min_bits, max_bits, </span><br><span class="line">      ((<span class="type">double</span>)total_bitmap_size) / (total_bitmap_entries ? total_bitmap_entries : <span class="number">1</span>),</span><br><span class="line">      DI(min_us), DI(max_us), DI(avg_us));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!timeout_given) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Figure out the appropriate timeout. The basic idea is: 5x average or</span></span><br><span class="line"><span class="comment">       1x max, rounded up to EXEC_TM_ROUND ms and capped at 1 second.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If the program is slow, the multiplier is lowered to 2x or 3x, because</span></span><br><span class="line"><span class="comment">       random scheduler jitter is less likely to have any impact, and because</span></span><br><span class="line"><span class="comment">       our patience is wearing thin =) */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avg_us &gt; <span class="number">50000</span>) exec_tmout = avg_us * <span class="number">2</span> / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (avg_us &gt; <span class="number">10000</span>) exec_tmout = avg_us * <span class="number">3</span> / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">else</span> exec_tmout = avg_us * <span class="number">5</span> / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    exec_tmout = MAX(exec_tmout, max_us / <span class="number">1000</span>);</span><br><span class="line">    exec_tmout = (exec_tmout + EXEC_TM_ROUND) / EXEC_TM_ROUND * EXEC_TM_ROUND;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exec_tmout &gt; EXEC_TIMEOUT) exec_tmout = EXEC_TIMEOUT;</span><br><span class="line"></span><br><span class="line">    ACTF(<span class="string">&quot;No -t option specified, so I&#x27;ll use exec timeout of %u ms.&quot;</span>, </span><br><span class="line">         exec_tmout);</span><br><span class="line"></span><br><span class="line">    timeout_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_given == <span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">    ACTF(<span class="string">&quot;Applying timeout settings from resumed session (%u ms).&quot;</span>, exec_tmout);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In dumb mode, re-running every timing out test case with a generous time</span></span><br><span class="line"><span class="comment">     limit is very expensive, so let&#x27;s select a more conservative default. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode &amp;&amp; !getenv(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>))</span><br><span class="line">    hang_tmout = MIN(EXEC_TIMEOUT, exec_tmout * <span class="number">2</span> + <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;All set and ready to roll!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>展示初始化的 stats</p>
<h2 id="find-start-position"><a href="#find-start-position" class="headerlink" title="find_start_position"></a>find_start_position</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* When resuming, try to find the queue position to start from. This makes sense</span></span><br><span class="line"><span class="comment">   only when resuming, and when we can find the original fuzzer_stats. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u32 <span class="title function_">find_start_position</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 tmp[<span class="number">4096</span>]; <span class="comment">/* Ought to be enough for anybody. */</span></span><br><span class="line"></span><br><span class="line">  u8  *fn, *off;</span><br><span class="line">  s32 fd, i;</span><br><span class="line">  u32 ret;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!resuming_fuzz) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_place_resume) fn = alloc_printf(<span class="string">&quot;%s/fuzzer_stats&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">else</span> fn = alloc_printf(<span class="string">&quot;%s/../fuzzer_stats&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  fd = open(fn, O_RDONLY);</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  i = read(fd, tmp, <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>); (<span class="type">void</span>)i; <span class="comment">/* Ignore errors */</span></span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">  off = <span class="built_in">strstr</span>(tmp, <span class="string">&quot;cur_path          : &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!off) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ret = atoi(off + <span class="number">20</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &gt;= queued_paths) ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>恢复时尝试找到队列位置开始</p>
<ul>
<li>如果没设置 resuming_fuzz 则返回</li>
<li>如果设置了 in_place_resume 则 fn 为 out_dir&#x2F;fuzzer_stats ，否则 fn 为 in_dir&#x2F;..&#x2F;fuzzer_stats</li>
<li>打开 fn 并读入内容</li>
<li>找寻 “cur_path          : “ 的 offset 并设置 ret</li>
<li>如果 ret 大于等于 queued_paths 就返回 0 ，否则返回 ret</li>
</ul>
<h2 id="write-stats-file"><a href="#write-stats-file" class="headerlink" title="write_stats_file"></a>write_stats_file</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Update stats file for unattended monitoring. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_stats_file</span><span class="params">(<span class="type">double</span> bitmap_cvg, <span class="type">double</span> stability, <span class="type">double</span> eps)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">double</span> last_bcvg, last_stab, last_eps;</span><br><span class="line">  <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rusage</span> <span class="title">usage</span>;</span></span><br><span class="line"></span><br><span class="line">  u8* fn = alloc_printf(<span class="string">&quot;%s/fuzzer_stats&quot;</span>, out_dir);</span><br><span class="line">  s32 fd;</span><br><span class="line">  FILE* f;</span><br><span class="line"></span><br><span class="line">  fd = open(fn, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  f = fdopen(fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!f) PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Keep last values in case we&#x27;re called from another context</span></span><br><span class="line"><span class="comment">     where exec/sec stats and such are not readily available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!bitmap_cvg &amp;&amp; !stability &amp;&amp; !eps) &#123;</span><br><span class="line">    bitmap_cvg = last_bcvg;</span><br><span class="line">    stability  = last_stab;</span><br><span class="line">    eps        = last_eps;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    last_bcvg = bitmap_cvg;</span><br><span class="line">    last_stab = stability;</span><br><span class="line">    last_eps  = eps;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(f, <span class="string">&quot;start_time        : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;last_update       : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;fuzzer_pid        : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;cycles_done       : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;execs_done        : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;execs_per_sec     : %0.02f\n&quot;</span></span><br><span class="line">             <span class="string">&quot;paths_total       : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;paths_favored     : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;paths_found       : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;paths_imported    : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;max_depth         : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;cur_path          : %u\n&quot;</span> <span class="comment">/* Must match find_start_position() */</span></span><br><span class="line">             <span class="string">&quot;pending_favs      : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;pending_total     : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;variable_paths    : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;stability         : %0.02f%%\n&quot;</span></span><br><span class="line">             <span class="string">&quot;bitmap_cvg        : %0.02f%%\n&quot;</span></span><br><span class="line">             <span class="string">&quot;unique_crashes    : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;unique_hangs      : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;last_path         : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;last_crash        : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;last_hang         : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;execs_since_crash : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;exec_timeout      : %u\n&quot;</span> <span class="comment">/* Must match find_timeout() */</span></span><br><span class="line">             <span class="string">&quot;afl_banner        : %s\n&quot;</span></span><br><span class="line">             <span class="string">&quot;afl_version       : &quot;</span> VERSION <span class="string">&quot;\n&quot;</span></span><br><span class="line">             <span class="string">&quot;target_mode       : %s%s%s%s%s%s%s\n&quot;</span></span><br><span class="line">             <span class="string">&quot;command_line      : %s\n&quot;</span></span><br><span class="line">             <span class="string">&quot;slowest_exec_ms   : %llu\n&quot;</span>,</span><br><span class="line">             start_time / <span class="number">1000</span>, get_cur_time() / <span class="number">1000</span>, getpid(),</span><br><span class="line">             queue_cycle ? (queue_cycle - <span class="number">1</span>) : <span class="number">0</span>, total_execs, eps,</span><br><span class="line">             queued_paths, queued_favored, queued_discovered, queued_imported,</span><br><span class="line">             max_depth, current_entry, pending_favored, pending_not_fuzzed,</span><br><span class="line">             queued_variable, stability, bitmap_cvg, unique_crashes,</span><br><span class="line">             unique_hangs, last_path_time / <span class="number">1000</span>, last_crash_time / <span class="number">1000</span>,</span><br><span class="line">             last_hang_time / <span class="number">1000</span>, total_execs - last_crash_execs,</span><br><span class="line">             exec_tmout, use_banner,</span><br><span class="line">             qemu_mode ? <span class="string">&quot;qemu &quot;</span> : <span class="string">&quot;&quot;</span>, dumb_mode ? <span class="string">&quot; dumb &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             no_forkserver ? <span class="string">&quot;no_forksrv &quot;</span> : <span class="string">&quot;&quot;</span>, crash_mode ? <span class="string">&quot;crash &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             persistent_mode ? <span class="string">&quot;persistent &quot;</span> : <span class="string">&quot;&quot;</span>, deferred_mode ? <span class="string">&quot;deferred &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             (qemu_mode || dumb_mode || no_forkserver || crash_mode ||</span><br><span class="line">              persistent_mode || deferred_mode) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;default&quot;</span>,</span><br><span class="line">             orig_cmdline, slowest_exec_ms);</span><br><span class="line">             <span class="comment">/* ignore errors */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get rss value from the children</span></span><br><span class="line"><span class="comment">     We must have killed the forkserver process and called waitpid</span></span><br><span class="line"><span class="comment">     before calling getrusage */</span></span><br><span class="line">  <span class="keyword">if</span> (getrusage(RUSAGE_CHILDREN, &amp;usage)) &#123;</span><br><span class="line">      WARNF(<span class="string">&quot;getrusage failed&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (usage.ru_maxrss == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;peak_rss_mb       : not available while afl is running\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;peak_rss_mb       : %zu\n&quot;</span>, usage.ru_maxrss &gt;&gt; <span class="number">20</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;peak_rss_mb       : %zu\n&quot;</span>, usage.ru_maxrss &gt;&gt; <span class="number">10</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fclose(f);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新状态信息，将信息写入 stats 文件</p>
<h2 id="save-auto"><a href="#save-auto" class="headerlink" title="save_auto"></a>save_auto</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Save automatically generated extras. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">save_auto</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!auto_changed) <span class="keyword">return</span>;</span><br><span class="line">  auto_changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MIN(USE_AUTO_EXTRAS, a_extras_cnt); i++) &#123;</span><br><span class="line"></span><br><span class="line">    u8* fn = alloc_printf(<span class="string">&quot;%s/queue/.state/auto_extras/auto_%06u&quot;</span>, out_dir, i);</span><br><span class="line">    s32 fd;</span><br><span class="line"></span><br><span class="line">    fd = open(fn, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    ck_write(fd, a_extras[i].data, a_extras[i].len, fn);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    ck_free(fn);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存自动生成的 extras</p>
<h1 id="Fuzz-执行"><a href="#Fuzz-执行" class="headerlink" title="Fuzz 执行"></a>Fuzz 执行</h1><p>Fuzz 执行在一个 while(1) 的循环里</p>
<h2 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">  u8 skipped_fuzz;</span><br><span class="line"></span><br><span class="line">  cull_queue();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!queue_cur) &#123;</span><br><span class="line"></span><br><span class="line">    queue_cycle++;</span><br><span class="line">    current_entry     = <span class="number">0</span>;</span><br><span class="line">    cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">    queue_cur         = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (seek_to) &#123;</span><br><span class="line">      current_entry++;</span><br><span class="line">      seek_to--;</span><br><span class="line">      queue_cur = queue_cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    show_stats();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">      ACTF(<span class="string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we had a full queue cycle with no new finds, try</span></span><br><span class="line"><span class="comment">       recombination strategies next. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queued_paths == prev_queued) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="keyword">else</span> use_splicing = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    prev_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; getenv(<span class="string">&quot;AFL_IMPORT_FIRST&quot;</span>))</span><br><span class="line">      sync_fuzzers(use_argv);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  skipped_fuzz = fuzz_one(use_argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">      sync_fuzzers(use_argv);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  queue_cur = queue_cur-&gt;next;</span><br><span class="line">  current_entry++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 cull_queue 精简队列</li>
<li>如果 queue_cur 为 0<ul>
<li>初始化 queue_cur 为 queue ，current_entry 和 cur_skipped_paths 为 0 并自增 queue_cycle ，之后循环递减 seek_to ，并通过 next 指针寻找 queue_cur ，同时递增 current_entry<ul>
<li>queue_cur  也就是当前 fuzz 的 queue</li>
</ul>
</li>
<li>调用 show_stats 显示 stats</li>
<li>如果设置了 not_on_tty  则打印 queue_cycle 并刷新 stdout</li>
<li>如果 queued_paths 等于 prev_queued ，则代表当前执行的 queue 里 case 的数量和之前一样，也就是没有新的 case<ul>
<li>如果设置了 use_splicing 则递增 cycles_wo_finds ，否则讲 use_splicing 置为 1</li>
</ul>
</li>
<li>否则设置 cycles_wo_finds 为 0</li>
<li>将 prev_queued 设置为 queued_paths</li>
<li>如果设置了 sync_id 且 queue_cycle 为 1 且有环境变量 AFL_IMPORT_FIRST<ul>
<li>调用 sync_fuzzers(use_argv)</li>
</ul>
</li>
</ul>
</li>
<li>调用 fuzz_one(use_argv) 并将返回值存储到 skipped_fuzz<ul>
<li>fuzz_one 并不一定会执行当前的 queue_cur ，它具有一定策略，如果不执行则返回 1 ，否则返回 0</li>
</ul>
</li>
<li>如果 stop_soon 为 0 且设置了 sync_id 且 skipped_fuzz 为 0<ul>
<li>如果 sync_interval_cnt++ % SYNC_INTERVAL 为 0 ，则执行 sync_fuzzers(use_argv)</li>
</ul>
</li>
<li>如果 stop_soon 为 0 且设置了 exit_1 ，则设置 stop_soon 为 2</li>
<li>如果设置了 stop_soon 则 break</li>
<li>设置 queue_cur 为 queue_cur→next ，也就是使用下一个 queue 进行下一轮 fuzz</li>
<li>递增 current_entry</li>
</ul>
<h2 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a><strong><strong>fuzz_one</strong></strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take the current entry from the queue, fuzz it for a while. This</span></span><br><span class="line"><span class="comment">   function is a tad too long... returns 0 if fuzzed successfully, 1 if</span></span><br><span class="line"><span class="comment">   skipped or bailed out. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u8 <span class="title function_">fuzz_one</span><span class="params">(<span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">	[...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面一大段，返回 0 则代表成功，返回 1 则代表 bailed out</p>
<h3 id="queue判断阶段"><a href="#queue判断阶段" class="headerlink" title="queue判断阶段"></a>queue判断阶段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IGNORE_FINDS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In IGNORE_FINDS mode, skip any entries that weren&#x27;t in the</span></span><br><span class="line"><span class="comment">     initial data set. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cur-&gt;depth &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pending_favored) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we have any favored, non-fuzzed new arrivals in the queue,</span></span><br><span class="line"><span class="comment">       possibly skip to them at the expense of already-fuzzed or non-favored</span></span><br><span class="line"><span class="comment">       cases. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((queue_cur-&gt;was_fuzzed || !queue_cur-&gt;favored) &amp;&amp;</span><br><span class="line">        UR(<span class="number">100</span>) &lt; SKIP_TO_NEW_PROB) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;favored &amp;&amp; queued_paths &gt; <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Otherwise, still possibly skip non-favored cases, albeit less often.</span></span><br><span class="line"><span class="comment">       The odds of skipping stuff are higher for already-fuzzed inputs and</span></span><br><span class="line"><span class="comment">       lower for never-fuzzed entries. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queue_cycle &gt; <span class="number">1</span> &amp;&amp; !queue_cur-&gt;was_fuzzed) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (UR(<span class="number">100</span>) &lt; SKIP_NFAV_NEW_PROB) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (UR(<span class="number">100</span>) &lt; SKIP_NFAV_OLD_PROB) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^IGNORE_FINDS */</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果定义了 IGNORE_FINDS  ，则跳过所有不在初始数据集中的条目</li>
<li>如果没有定义 IGNORE_FINDS<ul>
<li>如果设置了 pending_favored ，则有 99% 的概率跳过以下情况<ul>
<li>queue_cur-&gt;was_fuzzed 被设置的（被 fuzz 过的）</li>
<li>queue_cur-&gt;favored 没有被设置的（不感兴趣的）</li>
</ul>
</li>
<li>否则如果是 dumb 模式且不是 favored 且 queued_paths 大于 10 的话<ul>
<li>如果 queue_cycle 大于 1 且没有被设置 queue_cur-&gt;was_fuzzed<ul>
<li>有 75% 的概率跳过</li>
<li>否则有 95 的概率跳过</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>接下来进行一些初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">  ACTF(<span class="string">&quot;Fuzzing test case #%u (%u total, %llu uniq crashes found)...&quot;</span>,</span><br><span class="line">       current_entry, queued_paths, unique_crashes);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Map the test case into memory. */</span></span><br><span class="line"></span><br><span class="line">fd = open(queue_cur-&gt;fname, O_RDONLY);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, queue_cur-&gt;fname);</span><br><span class="line"></span><br><span class="line">len = queue_cur-&gt;len;</span><br><span class="line"></span><br><span class="line">orig_in = in_buf = mmap(<span class="number">0</span>, len, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (orig_in == MAP_FAILED) PFATAL(<span class="string">&quot;Unable to mmap &#x27;%s&#x27;&quot;</span>, queue_cur-&gt;fname);</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We could mmap() out_buf as MAP_PRIVATE, but we end up clobbering every</span></span><br><span class="line"><span class="comment">   single byte anyway, so it wouldn&#x27;t give us any performance or memory usage</span></span><br><span class="line"><span class="comment">   benefits. */</span></span><br><span class="line"></span><br><span class="line">out_buf = ck_alloc_nozero(len);</span><br><span class="line"></span><br><span class="line">subseq_tmouts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cur_depth = queue_cur-&gt;depth;</span><br></pre></td></tr></table></figure>

<p>主要就是打开了 queue_cur 所对应的用例文件，然后 mmap 出了 orig_in 和 in_buf ，同时 alloc 出了同样大小的 out_buf </p>
<h3 id="CALIBRATION阶段"><a href="#CALIBRATION阶段" class="headerlink" title="CALIBRATION阶段"></a><strong>CALIBRATION阶段</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment"> * CALIBRATION (only if failed earlier on) *</span></span><br><span class="line"><span class="comment"> *******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (queue_cur-&gt;cal_failed) &#123;</span><br><span class="line"></span><br><span class="line">  u8 res = FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cur-&gt;cal_failed &lt; CAL_CHANCES) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset exec_cksum to tell calibrate_case to re-execute the testcase</span></span><br><span class="line"><span class="comment">       avoiding the usage of an invalid trace_bits.</span></span><br><span class="line"><span class="comment">       For more info: https://github.com/AFLplusplus/AFLplusplus/pull/425 */</span></span><br><span class="line"></span><br><span class="line">    queue_cur-&gt;exec_cksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon || res != crash_mode) &#123;</span><br><span class="line">    cur_skipped_paths++;</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果设置了 queue_cur-&gt;cal_failed （有校准错误）<ul>
<li>如果 queue_cur-&gt;cal_failed 小于三次，则调用 calibrate_case 进行重新校准</li>
<li>之后如果设置了 stop_soon 或 res 不等于 crash_mode ，则递增 cur_skipped_paths 并跳到 abandon_entry</li>
</ul>
</li>
</ul>
<h3 id="TRIMMING阶段"><a href="#TRIMMING阶段" class="headerlink" title="TRIMMING阶段"></a>TRIMMING阶段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************</span></span><br><span class="line"><span class="comment"> * TRIMMING *</span></span><br><span class="line"><span class="comment"> ************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;trim_done) &#123;</span><br><span class="line"></span><br><span class="line">  u8 res = trim_case(argv, queue_cur, in_buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">    FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) &#123;</span><br><span class="line">    cur_skipped_paths++;</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don&#x27;t retry trimming, even if it failed. */</span></span><br><span class="line"></span><br><span class="line">  queue_cur-&gt;trim_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len != queue_cur-&gt;len) len = queue_cur-&gt;len;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果不是 dumb 模式且 queue_cur-&gt;trim_done 为 0 （该 case 没有被修剪过）<ul>
<li>调用 trim_case 进行修剪</li>
<li>如果设置了 stop_soon 则递增 cur_skipped_paths 并跳到 abandon_entry</li>
<li>设置 queue_cur-&gt;trim_done 为 1</li>
<li>如果 len 不等于 queue_cur-&gt;len 则更新 len 为 queue_cur-&gt;len</li>
</ul>
</li>
<li>最后将 in_buf 的值拷贝到 out_buf</li>
</ul>
<h3 id="PERFORMANCE-SCORE阶段"><a href="#PERFORMANCE-SCORE阶段" class="headerlink" title="PERFORMANCE SCORE阶段"></a>PERFORMANCE SCORE阶段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> * PERFORMANCE SCORE *</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"></span><br><span class="line">orig_perf = perf_score = calculate_score(queue_cur);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip right away if -d is given, if we have done deterministic fuzzing on</span></span><br><span class="line"><span class="comment">   this entry ourselves (was_fuzzed), or if it has gone through deterministic</span></span><br><span class="line"><span class="comment">   testing in earlier, resumed runs (passed_det). */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skip_deterministic || queue_cur-&gt;was_fuzzed || queue_cur-&gt;passed_det)</span><br><span class="line">  <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip deterministic fuzzing if exec path checksum puts this out of scope</span></span><br><span class="line"><span class="comment">   for this master instance. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (master_max &amp;&amp; (queue_cur-&gt;exec_cksum % master_max) != master_id - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">doing_det = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 calculate_score 计算分数并赋值给 orig_perf 和 perf_score</li>
<li>如果设置了 skip_deterministic  或 queue_cur-&gt;was_fuzzed 或 queue_cur-&gt;passed_det ，则跳到 havoc_stage</li>
<li>如果设置了 master_max 且 (queue_cur-&gt;exec_cksum % master_max) !&#x3D; master_id - 1 ，则跳到 havoc_stage</li>
<li>最后设置 doing_det 为 1</li>
</ul>
<h3 id="SIMPLE-BITFLIP-dictionary-construction-阶段"><a href="#SIMPLE-BITFLIP-dictionary-construction-阶段" class="headerlink" title="SIMPLE BITFLIP (+dictionary construction)阶段"></a>SIMPLE BITFLIP (+dictionary construction)阶段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment"> * SIMPLE BITFLIP (+dictionary construction) *</span></span><br><span class="line"><span class="comment"> *********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLIP_BIT(_ar, _b) do &#123; \</span></span><br><span class="line"><span class="meta">    u8* _arf = (u8*)(_ar); \</span></span><br><span class="line"><span class="meta">    u32 _bf = (_b); \</span></span><br><span class="line"><span class="meta">    _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7)); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Single walking bit. */</span></span><br><span class="line"></span><br><span class="line">  stage_short = <span class="string">&quot;flip1&quot;</span>;</span><br><span class="line">  stage_max   = len &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  stage_name  = <span class="string">&quot;bitflip 1/1&quot;</span>;</span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  prev_cksum = queue_cur-&gt;exec_cksum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* While flipping the least significant bit in every byte, pull of an extra</span></span><br><span class="line"><span class="comment">       trick to detect possible syntax tokens. In essence, the idea is that if</span></span><br><span class="line"><span class="comment">       you have a binary blob like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       xxxxxxxxIHDRxxxxxxxx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       ...and changing the leading and trailing bytes causes variable or no</span></span><br><span class="line"><span class="comment">       changes in program flow, but touching any character in the &quot;IHDR&quot; string</span></span><br><span class="line"><span class="comment">       always produces the same, distinctive path, it&#x27;s highly likely that</span></span><br><span class="line"><span class="comment">       &quot;IHDR&quot; is an atomically-checked magic value of special significance to</span></span><br><span class="line"><span class="comment">       the fuzzed format.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We do this here, rather than as a separate stage, because it&#x27;s a nice</span></span><br><span class="line"><span class="comment">       way to keep the operation approximately &quot;free&quot; (i.e., no extra execs).</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       Empirically, performing the check when flipping the least significant bit</span></span><br><span class="line"><span class="comment">       is advantageous, compared to doing it at the time of more disruptive</span></span><br><span class="line"><span class="comment">       changes, where the program flow may be affected in more violent ways.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The caveat is that we won&#x27;t generate dictionaries in the -d mode or -S</span></span><br><span class="line"><span class="comment">       mode - but that&#x27;s probably a fair trade-off.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       This won&#x27;t work particularly well with paths that exhibit variable</span></span><br><span class="line"><span class="comment">       behavior, but fails gracefully, so we&#x27;ll carry out the checks anyway.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode &amp;&amp; (stage_cur &amp; <span class="number">7</span>) == <span class="number">7</span>) &#123;</span><br><span class="line"></span><br><span class="line">      u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stage_cur == stage_max - <span class="number">1</span> &amp;&amp; cksum == prev_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If at end of file and we are still collecting a string, grab the</span></span><br><span class="line"><span class="comment">           final character and force output. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];</span><br><span class="line">        a_len++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">          maybe_add_auto(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != prev_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Otherwise, if the checksum has changed, see if we have something</span></span><br><span class="line"><span class="comment">           worthwhile queued up, and collect that if the answer is yes. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">          maybe_add_auto(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">        a_len = <span class="number">0</span>;</span><br><span class="line">        prev_cksum = cksum;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Continue collecting string, but only if the bit flip actually made</span></span><br><span class="line"><span class="comment">         any difference - we don&#x27;t want no-op tokens. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];        </span><br><span class="line">        a_len++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP1]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP1] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Two walking bits. */</span></span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;bitflip 2/1&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;flip2&quot;</span>;</span><br><span class="line">  stage_max   = (len &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP2]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP2] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Four walking bits. */</span></span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;bitflip 4/1&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;flip4&quot;</span>;</span><br><span class="line">  stage_max   = (len &lt;&lt; <span class="number">3</span>) - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP4]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP4] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Effector map setup. These macros calculate:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     EFF_APOS      - position of a particular file offset in the map.</span></span><br><span class="line"><span class="comment">     EFF_ALEN      - length of a map with a particular number of bytes.</span></span><br><span class="line"><span class="comment">     EFF_SPAN_ALEN - map span for a sequence of bytes.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_APOS(_p)          ((_p) &gt;&gt; EFF_MAP_SCALE2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_REM(_x)           ((_x) &amp; ((1 &lt;&lt; EFF_MAP_SCALE2) - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_ALEN(_l)          (EFF_APOS(_l) + !!EFF_REM(_l))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_SPAN_ALEN(_p, _l) (EFF_APOS((_p) + (_l) - 1) - EFF_APOS(_p) + 1)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize effector map for the next step (see comments below). Always</span></span><br><span class="line"><span class="comment">     flag first and last byte as doing something. */</span></span><br><span class="line"></span><br><span class="line">  eff_map    = ck_alloc(EFF_ALEN(len));</span><br><span class="line">  eff_map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (EFF_APOS(len - <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    eff_map[EFF_APOS(len - <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">    eff_cnt++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Walking byte. */</span></span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;bitflip 8/8&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;flip8&quot;</span>;</span><br><span class="line">  stage_max   = len;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur;</span><br><span class="line"></span><br><span class="line">    out_buf[stage_cur] ^= <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We also use this stage to pull off a simple trick: we identify</span></span><br><span class="line"><span class="comment">       bytes that seem to have no effect on the current execution path</span></span><br><span class="line"><span class="comment">       even when fully flipped - and we skip them during more expensive</span></span><br><span class="line"><span class="comment">       deterministic stages, such as arithmetics or known ints. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(stage_cur)]) &#123;</span><br><span class="line"></span><br><span class="line">      u32 cksum;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If in dumb mode or if the file is very short, just flag everything</span></span><br><span class="line"><span class="comment">         without wasting time on checksums. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!dumb_mode &amp;&amp; len &gt;= EFF_MIN_LEN)</span><br><span class="line">        cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        cksum = ~queue_cur-&gt;exec_cksum;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;</span><br><span class="line">        eff_map[EFF_APOS(stage_cur)] = <span class="number">1</span>;</span><br><span class="line">        eff_cnt++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out_buf[stage_cur] ^= <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the effector map is more than EFF_MAX_PERC dense, just flag the</span></span><br><span class="line"><span class="comment">     whole thing as worth fuzzing, since we wouldn&#x27;t be saving much time</span></span><br><span class="line"><span class="comment">     anyway. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (eff_cnt != EFF_ALEN(len) &amp;&amp;</span><br><span class="line">      eff_cnt * <span class="number">100</span> / EFF_ALEN(len) &gt; EFF_MAX_PERC) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(eff_map, <span class="number">1</span>, EFF_ALEN(len));</span><br><span class="line"></span><br><span class="line">    blocks_eff_select += EFF_ALEN(len);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    blocks_eff_select += eff_cnt;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  blocks_eff_total += EFF_ALEN(len);</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP8]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP8] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Two walking bytes. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">goto</span> skip_bitflip;</span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;bitflip 16/8&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;flip16&quot;</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)]) &#123;</span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    *(u16*)(out_buf + i) ^= <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">    *(u16*)(out_buf + i) ^= <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP16]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP16] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">4</span>) <span class="keyword">goto</span> skip_bitflip;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Four walking bytes. */</span></span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;bitflip 32/8&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;flip32&quot;</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = len - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)] &amp;&amp;</span><br><span class="line">        !eff_map[EFF_APOS(i + <span class="number">2</span>)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">3</span>)]) &#123;</span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    *(u32*)(out_buf + i) ^= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">    *(u32*)(out_buf + i) ^= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP32]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP32] += stage_max;</span><br><span class="line"></span><br><span class="line">skip_bitflip:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (no_arith) <span class="keyword">goto</span> skip_arith;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先定义了 FLIP_BIT 宏，也就是反转比特的操作</li>
<li>然后设置 stage_max 为当前比特数，并通过 stage_cur 进行比特遍历<ul>
<li>设置 stage_cur_byte 为 stage_cur &gt;&gt; 3</li>
<li>调用 FLIP_BIT(out_buf, stage_cur) 进行比特翻转</li>
<li>调用 common_fuzz_stuff 进行样例测试，如果返回不为 0 则跳到 abandon_entry</li>
<li>再次调用 FLIP_BIT(out_buf, stage_cur) 进行比特翻转（还原）</li>
<li>当不是 dumb 模式且 stage_cur &amp; 7 等于 7 的时候（也就是该字节的所有比特都进行了翻转）<ul>
<li><strong>会进行 token 的判断与捕获，比如说对于 SQL 语句的 Select 关键字，其变化任何一个字符的比特都会导致走到相同的错误路径，且与原始执行路径不一样，那么下面就会去捕获这个 token</strong></li>
<li>计算当前的 cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST)</li>
<li>当 stage_cur 走到最后且 cksum 与 prev_cksum 相同时<ul>
<li>如果在文件末尾并且我们仍在收集字符串，则获取最后一个字符并强制输出</li>
<li>如果 a_len 小于 MAX_AUTO_EXTRA（32）<ul>
<li>a_collect[a_len] &#x3D; out_buf[stage_cur &gt;&gt; 3]</li>
<li>递增 a_len</li>
</ul>
</li>
<li>如果 a_len 大于等于 MIN_AUTO_EXTRA（3）且小于等于 MAX_AUTO_EXTRA（32）<ul>
<li>通过 maybe_add_auto(a_collect, a_len) 将新的 token 添加到 a_extras 数组里</li>
</ul>
</li>
</ul>
</li>
<li>否则当 cksum 与 prev_cksum 不同时<ul>
<li>如果 a_len 大于等于 MIN_AUTO_EXTRA（3）且小于等于 MAX_AUTO_EXTRA（32）<ul>
<li>通过 maybe_add_auto(a_collect, a_len) 将新的 token 添加到 a_extras 数组里</li>
</ul>
</li>
<li>设置 a_len 为 0 且 prev_cksum 为 cksum</li>
</ul>
</li>
<li>继续收集字符串 token ，如果 cksum 不等于 queue_cur-&gt;exec_cksum<ul>
<li>如果 a_len 小于 MAX_AUTO_EXTRA（32），则设置 a_collect[a_len] 为 out_buf[stage_cur &gt;&gt; 3]</li>
<li>递增 a_len</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>设置 new_hit_cnt 为 queued_paths 和 unique_crashes 的和</li>
<li>将 stage_finds[STAGE_FLIP1] 加上 new_hit_cnt - orig_hit_cnt ，stage_cycles[STAGE_FLIP1] 加上 stage_max</li>
<li>之后进入相邻比特的翻转流程，设置 stage_max 为当前比特数，并通过 stage_cur 进行比特遍历<ul>
<li>同时调用 FLIP_BIT 翻转 stage_cur 和 stage_cur+1 处的比特</li>
<li>调用 common_fuzz_stuff 进行样例测试，如果返回不为 0 则跳到 abandon_entry</li>
<li>再次调用 FLIP_BIT(out_buf, stage_cur) 进行比特翻转（还原）</li>
</ul>
</li>
<li>更新 new_hit_cnt 以及 tage_finds[STAGE_FLIP2] 和 stage_cycles[STAGE_FLIP2]</li>
<li>之后进入相邻 4 比特的翻转流程，和上面的相邻比特翻转一样</li>
<li>设立 Effector Map ，并进行相邻 8 比特，也就是 1 字节的翻转流程<ul>
<li>如果对每个字节进行翻转的时候，其执行路径与原始路径不一致，则在 Effector Map 中的对应位置标志为 1 ，也就是有效的；否则标志为 0 ，也就是无效的</li>
<li><strong>这样做是为了收集信息，如果路径不同则代表这里可能是个 metadata（比如 flags），否则则可能是个数据。在之后的变异中会跳过这些数据内容，从而提高效率。</strong></li>
</ul>
</li>
<li>之后进入相邻 2 字节的翻转流程，其会在 Effector Map 中检查这 2 字节的标志位是否为 0 ，如果是则跳过</li>
<li>最后进入相邻 4 字节的翻转流程，其会在 Effector Map 中检查这 4 字节的标志位是否为 0 ，如果是则跳过</li>
<li>末尾有跳转的 label skip_bitflip ，如果设置了 no_arith ，则跳到 skip_arith</li>
</ul>
<h3 id="ARITHMETIC-INC-x2F-DEC阶段"><a href="#ARITHMETIC-INC-x2F-DEC阶段" class="headerlink" title="ARITHMETIC INC&#x2F;DEC阶段"></a>ARITHMETIC INC&#x2F;DEC阶段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************</span></span><br><span class="line"><span class="comment"> * ARITHMETIC INC/DEC *</span></span><br><span class="line"><span class="comment"> **********************/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 8-bit arithmetics. */</span></span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;arith 8/8&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;arith8&quot;</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = <span class="number">2</span> * len * ARITH_MAX;</span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u8 orig = out_buf[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)]) &#123;</span><br><span class="line">      stage_max -= <span class="number">2</span> * ARITH_MAX;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= ARITH_MAX; j++) &#123;</span><br><span class="line"></span><br><span class="line">      u8 r = orig ^ (orig + j);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Do arithmetic operations only if the result couldn&#x27;t be a product</span></span><br><span class="line"><span class="comment">         of a bitflip. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!could_be_bitflip(r)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_cur_val = j;</span><br><span class="line">        out_buf[i] = orig + j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      r =  orig ^ (orig - j);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!could_be_bitflip(r)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_cur_val = -j;</span><br><span class="line">        out_buf[i] = orig - j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      out_buf[i] = orig;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_ARITH8]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_ARITH8] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 16-bit arithmetics, both endians. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">goto</span> skip_arith;</span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;arith 16/8&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;arith16&quot;</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = <span class="number">4</span> * (len - <span class="number">1</span>) * ARITH_MAX;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u16 orig = *(u16*)(out_buf + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)]) &#123;</span><br><span class="line">      stage_max -= <span class="number">4</span> * ARITH_MAX;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= ARITH_MAX; j++) &#123;</span><br><span class="line"></span><br><span class="line">      u16 r1 = orig ^ (orig + j),</span><br><span class="line">          r2 = orig ^ (orig - j),</span><br><span class="line">          r3 = orig ^ SWAP16(SWAP16(orig) + j),</span><br><span class="line">          r4 = orig ^ SWAP16(SWAP16(orig) - j);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try little endian addition and subtraction first. Do it only</span></span><br><span class="line"><span class="comment">         if the operation would affect more than one byte (hence the </span></span><br><span class="line"><span class="comment">         &amp; 0xff overflow checks) and if it couldn&#x27;t be a product of</span></span><br><span class="line"><span class="comment">         a bitflip. */</span></span><br><span class="line"></span><br><span class="line">      stage_val_type = STAGE_VAL_LE; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((orig &amp; <span class="number">0xff</span>) + j &gt; <span class="number">0xff</span> &amp;&amp; !could_be_bitflip(r1)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_cur_val = j;</span><br><span class="line">        *(u16*)(out_buf + i) = orig + j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"> </span><br><span class="line">      &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((orig &amp; <span class="number">0xff</span>) &lt; j &amp;&amp; !could_be_bitflip(r2)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_cur_val = -j;</span><br><span class="line">        *(u16*)(out_buf + i) = orig - j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Big endian comes next. Same deal. */</span></span><br><span class="line"></span><br><span class="line">      stage_val_type = STAGE_VAL_BE;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((orig &gt;&gt; <span class="number">8</span>) + j &gt; <span class="number">0xff</span> &amp;&amp; !could_be_bitflip(r3)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_cur_val = j;</span><br><span class="line">        *(u16*)(out_buf + i) = SWAP16(SWAP16(orig) + j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((orig &gt;&gt; <span class="number">8</span>) &lt; j &amp;&amp; !could_be_bitflip(r4)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_cur_val = -j;</span><br><span class="line">        *(u16*)(out_buf + i) = SWAP16(SWAP16(orig) - j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      *(u16*)(out_buf + i) = orig;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_ARITH16]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_ARITH16] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 32-bit arithmetics, both endians. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">4</span>) <span class="keyword">goto</span> skip_arith;</span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;arith 32/8&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;arith32&quot;</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = <span class="number">4</span> * (len - <span class="number">3</span>) * ARITH_MAX;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 orig = *(u32*)(out_buf + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)] &amp;&amp;</span><br><span class="line">        !eff_map[EFF_APOS(i + <span class="number">2</span>)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">3</span>)]) &#123;</span><br><span class="line">      stage_max -= <span class="number">4</span> * ARITH_MAX;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= ARITH_MAX; j++) &#123;</span><br><span class="line"></span><br><span class="line">      u32 r1 = orig ^ (orig + j),</span><br><span class="line">          r2 = orig ^ (orig - j),</span><br><span class="line">          r3 = orig ^ SWAP32(SWAP32(orig) + j),</span><br><span class="line">          r4 = orig ^ SWAP32(SWAP32(orig) - j);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Little endian first. Same deal as with 16-bit: we only want to</span></span><br><span class="line"><span class="comment">         try if the operation would have effect on more than two bytes. */</span></span><br><span class="line"></span><br><span class="line">      stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((orig &amp; <span class="number">0xffff</span>) + j &gt; <span class="number">0xffff</span> &amp;&amp; !could_be_bitflip(r1)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_cur_val = j;</span><br><span class="line">        *(u32*)(out_buf + i) = orig + j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((orig &amp; <span class="number">0xffff</span>) &lt; j &amp;&amp; !could_be_bitflip(r2)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_cur_val = -j;</span><br><span class="line">        *(u32*)(out_buf + i) = orig - j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Big endian next. */</span></span><br><span class="line"></span><br><span class="line">      stage_val_type = STAGE_VAL_BE;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((SWAP32(orig) &amp; <span class="number">0xffff</span>) + j &gt; <span class="number">0xffff</span> &amp;&amp; !could_be_bitflip(r3)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_cur_val = j;</span><br><span class="line">        *(u32*)(out_buf + i) = SWAP32(SWAP32(orig) + j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((SWAP32(orig) &amp; <span class="number">0xffff</span>) &lt; j &amp;&amp; !could_be_bitflip(r4)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_cur_val = -j;</span><br><span class="line">        *(u32*)(out_buf + i) = SWAP32(SWAP32(orig) - j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      *(u32*)(out_buf + i) = orig;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_ARITH32]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_ARITH32] += stage_max;</span><br><span class="line"></span><br><span class="line">skip_arith:</span><br></pre></td></tr></table></figure>

<ul>
<li>首先对一个字节进行加减法操作变异，也会通过 Effector Map 跳过无效的字节，并且会检查该操作是否是字节翻转，如果是的话则跳过<ul>
<li>变化的例子如下<ul>
<li>r &#x3D; orig ^ (orig + j)</li>
<li>r &#x3D; orig ^ (orig - j)</li>
</ul>
</li>
</ul>
</li>
<li>然后对两个字节进行加减法操作变异（每个字节）。如果数据长度不满足变异的长度则跳过该阶段</li>
<li>最后对四个字节进行加减法操作变异（每两个字节为一组，对每组进行操作）。如果数据长度不满足变异的长度则跳过该阶段</li>
<li>加减法变异的上限为 ARITH_MAX（35），也就是 [-35,+35] ，同时也会对大端序小端序进行变异</li>
</ul>
<h3 id="INTERESTING-VALUES阶段"><a href="#INTERESTING-VALUES阶段" class="headerlink" title="INTERESTING VALUES阶段"></a>INTERESTING VALUES阶段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************</span></span><br><span class="line"><span class="comment"> * INTERESTING VALUES *</span></span><br><span class="line"><span class="comment"> **********************/</span></span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;interest 8/8&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;int8&quot;</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = len * <span class="keyword">sizeof</span>(interesting_8);</span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Setting 8-bit integers. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u8 orig = out_buf[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)]) &#123;</span><br><span class="line">      stage_max -= <span class="keyword">sizeof</span>(interesting_8);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(interesting_8); j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip if the value could be a product of bitflips or arithmetics. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (could_be_bitflip(orig ^ (u8)interesting_8[j]) ||</span><br><span class="line">          could_be_arith(orig, (u8)interesting_8[j], <span class="number">1</span>)) &#123;</span><br><span class="line">        stage_max--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      stage_cur_val = interesting_8[j];</span><br><span class="line">      out_buf[i] = interesting_8[j];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">      out_buf[i] = orig;</span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_INTEREST8]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_INTEREST8] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Setting 16-bit integers, both endians. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (no_arith || len &lt; <span class="number">2</span>) <span class="keyword">goto</span> skip_interest;</span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;interest 16/8&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;int16&quot;</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = <span class="number">2</span> * (len - <span class="number">1</span>) * (<span class="keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u16 orig = *(u16*)(out_buf + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)]) &#123;</span><br><span class="line">      stage_max -= <span class="keyword">sizeof</span>(interesting_16);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(interesting_16) / <span class="number">2</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      stage_cur_val = interesting_16[j];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip if this could be a product of a bitflip, arithmetics,</span></span><br><span class="line"><span class="comment">         or single-byte interesting value insertion. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!could_be_bitflip(orig ^ (u16)interesting_16[j]) &amp;&amp;</span><br><span class="line">          !could_be_arith(orig, (u16)interesting_16[j], <span class="number">2</span>) &amp;&amp;</span><br><span class="line">          !could_be_interest(orig, (u16)interesting_16[j], <span class="number">2</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">        *(u16*)(out_buf + i) = interesting_16[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((u16)interesting_16[j] != SWAP16(interesting_16[j]) &amp;&amp;</span><br><span class="line">          !could_be_bitflip(orig ^ SWAP16(interesting_16[j])) &amp;&amp;</span><br><span class="line">          !could_be_arith(orig, SWAP16(interesting_16[j]), <span class="number">2</span>) &amp;&amp;</span><br><span class="line">          !could_be_interest(orig, SWAP16(interesting_16[j]), <span class="number">2</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_val_type = STAGE_VAL_BE;</span><br><span class="line"></span><br><span class="line">        *(u16*)(out_buf + i) = SWAP16(interesting_16[j]);</span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(u16*)(out_buf + i) = orig;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_INTEREST16]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_INTEREST16] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">4</span>) <span class="keyword">goto</span> skip_interest;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Setting 32-bit integers, both endians. */</span></span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;interest 32/8&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;int32&quot;</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = <span class="number">2</span> * (len - <span class="number">3</span>) * (<span class="keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 orig = *(u32*)(out_buf + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)] &amp;&amp;</span><br><span class="line">        !eff_map[EFF_APOS(i + <span class="number">2</span>)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">3</span>)]) &#123;</span><br><span class="line">      stage_max -= <span class="keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(interesting_32) / <span class="number">4</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      stage_cur_val = interesting_32[j];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip if this could be a product of a bitflip, arithmetics,</span></span><br><span class="line"><span class="comment">         or word interesting value insertion. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!could_be_bitflip(orig ^ (u32)interesting_32[j]) &amp;&amp;</span><br><span class="line">          !could_be_arith(orig, interesting_32[j], <span class="number">4</span>) &amp;&amp;</span><br><span class="line">          !could_be_interest(orig, interesting_32[j], <span class="number">4</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">        *(u32*)(out_buf + i) = interesting_32[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((u32)interesting_32[j] != SWAP32(interesting_32[j]) &amp;&amp;</span><br><span class="line">          !could_be_bitflip(orig ^ SWAP32(interesting_32[j])) &amp;&amp;</span><br><span class="line">          !could_be_arith(orig, SWAP32(interesting_32[j]), <span class="number">4</span>) &amp;&amp;</span><br><span class="line">          !could_be_interest(orig, SWAP32(interesting_32[j]), <span class="number">4</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_val_type = STAGE_VAL_BE;</span><br><span class="line"></span><br><span class="line">        *(u32*)(out_buf + i) = SWAP32(interesting_32[j]);</span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(u32*)(out_buf + i) = orig;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_INTEREST32]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_INTEREST32] += stage_max;</span><br><span class="line"></span><br><span class="line">skip_interest:</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该阶段会跳过可能变异出前两个阶段的内容，也会跳过该阶段上一次的内容（例如二字节变异会跳过一字节变异可能出现的情况）。同时也会根据 Effector Map 跳过一些阶段</p>
</li>
<li><p>主要就是替换一二四字节的内容为下面的一些特殊边界值</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* List of interesting values to use in fuzzing. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_8 \</span></span><br><span class="line"><span class="meta">  -128,          <span class="comment">/* Overflow signed 8-bit when decremented  */</span> \</span></span><br><span class="line"><span class="meta">  -1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   0,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   16,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   64,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   100,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   127           <span class="comment">/* Overflow signed 8-bit when incremented  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_16 \</span></span><br><span class="line"><span class="meta">  -32768,        <span class="comment">/* Overflow signed 16-bit when decremented */</span> \</span></span><br><span class="line"><span class="meta">  -129,          <span class="comment">/* Overflow signed 8-bit                   */</span> \</span></span><br><span class="line"><span class="meta">   128,          <span class="comment">/* Overflow signed 8-bit                   */</span> \</span></span><br><span class="line"><span class="meta">   255,          <span class="comment">/* Overflow unsig 8-bit when incremented   */</span> \</span></span><br><span class="line"><span class="meta">   256,          <span class="comment">/* Overflow unsig 8-bit                    */</span> \</span></span><br><span class="line"><span class="meta">   512,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   1000,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   1024,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   4096,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32767         <span class="comment">/* Overflow signed 16-bit when incremented */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_32 \</span></span><br><span class="line"><span class="meta">  -2147483648LL, <span class="comment">/* Overflow signed 32-bit when decremented */</span> \</span></span><br><span class="line"><span class="meta">  -100663046,    <span class="comment">/* Large negative number (endian-agnostic) */</span> \</span></span><br><span class="line"><span class="meta">  -32769,        <span class="comment">/* Overflow signed 16-bit                  */</span> \</span></span><br><span class="line"><span class="meta">   32768,        <span class="comment">/* Overflow signed 16-bit                  */</span> \</span></span><br><span class="line"><span class="meta">   65535,        <span class="comment">/* Overflow unsig 16-bit when incremented  */</span> \</span></span><br><span class="line"><span class="meta">   65536,        <span class="comment">/* Overflow unsig 16 bit                   */</span> \</span></span><br><span class="line"><span class="meta">   100663045,    <span class="comment">/* Large positive number (endian-agnostic) */</span> \</span></span><br><span class="line"><span class="meta">   2147483647    <span class="comment">/* Overflow signed 32-bit when incremented */</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="DICTIONARY-STUFF阶段"><a href="#DICTIONARY-STUFF阶段" class="headerlink" title="DICTIONARY STUFF阶段"></a>DICTIONARY STUFF阶段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************</span></span><br><span class="line"><span class="comment"> * DICTIONARY STUFF *</span></span><br><span class="line"><span class="comment"> ********************/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!extras_cnt) <span class="keyword">goto</span> skip_user_extras;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Overwrite with user-supplied extras. */</span></span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;user extras (over)&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;ext_UO&quot;</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = extras_cnt * len;</span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 last_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Extras are sorted by size, from smallest to largest. This means</span></span><br><span class="line"><span class="comment">       that we don&#x27;t have to worry about restoring the buffer in</span></span><br><span class="line"><span class="comment">       between writes at a particular offset determined by the outer</span></span><br><span class="line"><span class="comment">       loop. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; extras_cnt; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip extras probabilistically if extras_cnt &gt; MAX_DET_EXTRAS. Also</span></span><br><span class="line"><span class="comment">         skip them if there&#x27;s no room to insert the payload, if the token</span></span><br><span class="line"><span class="comment">         is redundant, or if its entire span has no bytes set in the effector</span></span><br><span class="line"><span class="comment">         map. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((extras_cnt &gt; MAX_DET_EXTRAS &amp;&amp; UR(extras_cnt) &gt;= MAX_DET_EXTRAS) ||</span><br><span class="line">          extras[j].len &gt; len - i ||</span><br><span class="line">          !<span class="built_in">memcmp</span>(extras[j].data, out_buf + i, extras[j].len) ||</span><br><span class="line">          !<span class="built_in">memchr</span>(eff_map + EFF_APOS(i), <span class="number">1</span>, EFF_SPAN_ALEN(i, extras[j].len))) &#123;</span><br><span class="line"></span><br><span class="line">        stage_max--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      last_len = extras[j].len;</span><br><span class="line">      <span class="built_in">memcpy</span>(out_buf + i, extras[j].data, last_len);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore all the clobbered memory. */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_EXTRAS_UO]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_EXTRAS_UO] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Insertion of user-supplied extras. */</span></span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;user extras (insert)&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;ext_UI&quot;</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = extras_cnt * (len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  ex_tmp = ck_alloc(len + MAX_DICT_FILE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; extras_cnt; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (len + extras[j].len &gt; MAX_FILE) &#123;</span><br><span class="line">        stage_max--; </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Insert token */</span></span><br><span class="line">      <span class="built_in">memcpy</span>(ex_tmp + i, extras[j].data, extras[j].len);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Copy tail */</span></span><br><span class="line">      <span class="built_in">memcpy</span>(ex_tmp + i + extras[j].len, out_buf + i, len - i);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (common_fuzz_stuff(argv, ex_tmp, len + extras[j].len)) &#123;</span><br><span class="line">        ck_free(ex_tmp);</span><br><span class="line">        <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy head */</span></span><br><span class="line">    ex_tmp[i] = out_buf[i];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ck_free(ex_tmp);</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_EXTRAS_UI]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_EXTRAS_UI] += stage_max;</span><br><span class="line"></span><br><span class="line">skip_user_extras:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!a_extras_cnt) <span class="keyword">goto</span> skip_extras;</span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;auto extras (over)&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;ext_AO&quot;</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len;</span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 last_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MIN(a_extras_cnt, USE_AUTO_EXTRAS); j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* See the comment in the earlier code; extras are sorted by size. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (a_extras[j].len &gt; len - i ||</span><br><span class="line">          !<span class="built_in">memcmp</span>(a_extras[j].data, out_buf + i, a_extras[j].len) ||</span><br><span class="line">          !<span class="built_in">memchr</span>(eff_map + EFF_APOS(i), <span class="number">1</span>, EFF_SPAN_ALEN(i, a_extras[j].len))) &#123;</span><br><span class="line"></span><br><span class="line">        stage_max--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      last_len = a_extras[j].len;</span><br><span class="line">      <span class="built_in">memcpy</span>(out_buf + i, a_extras[j].data, last_len);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore all the clobbered memory. */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_EXTRAS_AO]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_EXTRAS_AO] += stage_max;</span><br><span class="line"></span><br><span class="line">skip_extras:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we made this to here without jumping to havoc_stage or abandon_entry,</span></span><br><span class="line"><span class="comment">     we&#x27;re properly done with deterministic steps and can mark it as such</span></span><br><span class="line"><span class="comment">     in the .state/ directory. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!queue_cur-&gt;passed_det) mark_as_det_done(queue_cur);</span><br></pre></td></tr></table></figure>

<ul>
<li>该阶段会将 a_extras 里面的特殊 token 进行替换，主要有以下三类：<ul>
<li>替换<ul>
<li>user extras ：stage_max 为 extras_cnt * len</li>
<li>auto extras ：stage_max 为 MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len</li>
</ul>
</li>
<li>插入<ul>
<li>user extras：stage_max 为 extras_cnt * len</li>
</ul>
</li>
</ul>
</li>
<li>其中的 user extras 为用户给的，加入 -x 指令便可加入</li>
</ul>
<p>该阶段也是 deterministic fuzzing 的最后一步</p>
<h3 id="RANDOM-HAVOC阶段"><a href="#RANDOM-HAVOC阶段" class="headerlink" title="RANDOM HAVOC阶段"></a>RANDOM HAVOC阶段</h3><p>对于 dumb 模式来说这是起始阶段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************</span></span><br><span class="line"><span class="comment"> * RANDOM HAVOC *</span></span><br><span class="line"><span class="comment"> ****************/</span></span><br><span class="line"></span><br><span class="line">havoc_stage:</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The havoc stage mutation code is also invoked when splicing files; if the</span></span><br><span class="line"><span class="comment">     splice_cycle variable is set, generate different descriptions and such. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!splice_cycle) &#123;</span><br><span class="line"></span><br><span class="line">    stage_name  = <span class="string">&quot;havoc&quot;</span>;</span><br><span class="line">    stage_short = <span class="string">&quot;havoc&quot;</span>;</span><br><span class="line">    stage_max   = (doing_det ? HAVOC_CYCLES_INIT : HAVOC_CYCLES) *</span><br><span class="line">                  perf_score / havoc_div / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> u8 tmp[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    perf_score = orig_perf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;splice %u&quot;</span>, splice_cycle);</span><br><span class="line">    stage_name  = tmp;</span><br><span class="line">    stage_short = <span class="string">&quot;splice&quot;</span>;</span><br><span class="line">    stage_max   = SPLICE_HAVOC * perf_score / havoc_div / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stage_max &lt; HAVOC_MIN) stage_max = HAVOC_MIN;</span><br><span class="line"></span><br><span class="line">  temp_len = len;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  havoc_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We essentially just do several thousand runs (depending on perf_score)</span></span><br><span class="line"><span class="comment">     where we take the input file and make random stacked tweaks. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 use_stacking = <span class="number">1</span> &lt;&lt; (<span class="number">1</span> + UR(HAVOC_STACK_POW2));</span><br><span class="line"></span><br><span class="line">    stage_cur_val = use_stacking;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; use_stacking; i++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (UR(<span class="number">15</span> + ((extras_cnt + a_extras_cnt) ? <span class="number">2</span> : <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Flip a single bit somewhere. Spooky! */</span></span><br><span class="line"></span><br><span class="line">          FLIP_BIT(out_buf, UR(temp_len &lt;&lt; <span class="number">3</span>));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Set byte to interesting value. */</span></span><br><span class="line"></span><br><span class="line">          out_buf[UR(temp_len)] = interesting_8[UR(<span class="keyword">sizeof</span>(interesting_8))];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Set word to interesting value, randomly choosing endian. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            *(u16*)(out_buf + UR(temp_len - <span class="number">1</span>)) =</span><br><span class="line">              interesting_16[UR(<span class="keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            *(u16*)(out_buf + UR(temp_len - <span class="number">1</span>)) = SWAP16(</span><br><span class="line">              interesting_16[UR(<span class="keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>)]);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Set dword to interesting value, randomly choosing endian. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len &lt; <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line">  </span><br><span class="line">            *(u32*)(out_buf + UR(temp_len - <span class="number">3</span>)) =</span><br><span class="line">              interesting_32[UR(<span class="keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>)];</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            *(u32*)(out_buf + UR(temp_len - <span class="number">3</span>)) = SWAP32(</span><br><span class="line">              interesting_32[UR(<span class="keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>)]);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Randomly subtract from byte. */</span></span><br><span class="line"></span><br><span class="line">          out_buf[UR(temp_len)] -= <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Randomly add to byte. */</span></span><br><span class="line"></span><br><span class="line">          out_buf[UR(temp_len)] += <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Randomly subtract from word, random endian. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            *(u16*)(out_buf + pos) -= <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line">            u16 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">            *(u16*)(out_buf + pos) =</span><br><span class="line">              SWAP16(SWAP16(*(u16*)(out_buf + pos)) - num);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Randomly add to word, random endian. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            *(u16*)(out_buf + pos) += <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line">            u16 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">            *(u16*)(out_buf + pos) =</span><br><span class="line">              SWAP16(SWAP16(*(u16*)(out_buf + pos)) + num);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Randomly subtract from dword, random endian. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len &lt; <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            *(u32*)(out_buf + pos) -= <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line">            u32 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">            *(u32*)(out_buf + pos) =</span><br><span class="line">              SWAP32(SWAP32(*(u32*)(out_buf + pos)) - num);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Randomly add to dword, random endian. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len &lt; <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            *(u32*)(out_buf + pos) += <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line">            u32 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">            *(u32*)(out_buf + pos) =</span><br><span class="line">              SWAP32(SWAP32(*(u32*)(out_buf + pos)) + num);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Just set a random byte to a random value. Because,</span></span><br><span class="line"><span class="comment">             why not. We use XOR with 1-255 to eliminate the</span></span><br><span class="line"><span class="comment">             possibility of a no-op. */</span></span><br><span class="line"></span><br><span class="line">          out_buf[UR(temp_len)] ^= <span class="number">1</span> + UR(<span class="number">255</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span> ... <span class="number">12</span>: &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Delete bytes. We&#x27;re making this a bit more likely</span></span><br><span class="line"><span class="comment">               than insertion (the next option) in hopes of keeping</span></span><br><span class="line"><span class="comment">               files reasonably small. */</span></span><br><span class="line"></span><br><span class="line">            u32 del_from, del_len;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Don&#x27;t delete too much. */</span></span><br><span class="line"></span><br><span class="line">            del_len = choose_block_len(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            del_from = UR(temp_len - del_len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            memmove(out_buf + del_from, out_buf + del_from + del_len,</span><br><span class="line">                    temp_len - del_from - del_len);</span><br><span class="line"></span><br><span class="line">            temp_len -= del_len;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len + HAVOC_BLK_XL &lt; MAX_FILE) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Clone bytes (75%) or insert a block of constant bytes (25%). */</span></span><br><span class="line"></span><br><span class="line">            u8  actually_clone = UR(<span class="number">4</span>);</span><br><span class="line">            u32 clone_from, clone_to, clone_len;</span><br><span class="line">            u8* new_buf;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (actually_clone) &#123;</span><br><span class="line"></span><br><span class="line">              clone_len  = choose_block_len(temp_len);</span><br><span class="line">              clone_from = UR(temp_len - clone_len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">              clone_len = choose_block_len(HAVOC_BLK_XL);</span><br><span class="line">              clone_from = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clone_to   = UR(temp_len);</span><br><span class="line"></span><br><span class="line">            new_buf = ck_alloc_nozero(temp_len + clone_len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Head */</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf, out_buf, clone_to);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Inserted part */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (actually_clone)</span><br><span class="line">              <span class="built_in">memcpy</span>(new_buf + clone_to, out_buf + clone_from, clone_len);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              <span class="built_in">memset</span>(new_buf + clone_to,</span><br><span class="line">                     UR(<span class="number">2</span>) ? UR(<span class="number">256</span>) : out_buf[UR(temp_len)], clone_len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Tail */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf + clone_to + clone_len, out_buf + clone_to,</span><br><span class="line">                   temp_len - clone_to);</span><br><span class="line"></span><br><span class="line">            ck_free(out_buf);</span><br><span class="line">            out_buf = new_buf;</span><br><span class="line">            temp_len += clone_len;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">14</span>: &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Overwrite bytes with a randomly selected chunk (75%) or fixed</span></span><br><span class="line"><span class="comment">               bytes (25%). */</span></span><br><span class="line"></span><br><span class="line">            u32 copy_from, copy_to, copy_len;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            copy_len  = choose_block_len(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            copy_from = UR(temp_len - copy_len + <span class="number">1</span>);</span><br><span class="line">            copy_to   = UR(temp_len - copy_len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (UR(<span class="number">4</span>)) &#123;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (copy_from != copy_to)</span><br><span class="line">                memmove(out_buf + copy_to, out_buf + copy_from, copy_len);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">memset</span>(out_buf + copy_to,</span><br><span class="line">                          UR(<span class="number">2</span>) ? UR(<span class="number">256</span>) : out_buf[UR(temp_len)], copy_len);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Values 15 and 16 can be selected only if there are any extras</span></span><br><span class="line"><span class="comment">           present in the dictionaries. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">15</span>: &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Overwrite bytes with an extra. */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!extras_cnt || (a_extras_cnt &amp;&amp; UR(<span class="number">2</span>))) &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* No user-specified extras or odds in our favor. Let&#x27;s use an</span></span><br><span class="line"><span class="comment">                 auto-detected one. */</span></span><br><span class="line"></span><br><span class="line">              u32 use_extra = UR(a_extras_cnt);</span><br><span class="line">              u32 extra_len = a_extras[use_extra].len;</span><br><span class="line">              u32 insert_at;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (extra_len &gt; temp_len) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              insert_at = UR(temp_len - extra_len + <span class="number">1</span>);</span><br><span class="line">              <span class="built_in">memcpy</span>(out_buf + insert_at, a_extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* No auto extras or odds in our favor. Use the dictionary. */</span></span><br><span class="line"></span><br><span class="line">              u32 use_extra = UR(extras_cnt);</span><br><span class="line">              u32 extra_len = extras[use_extra].len;</span><br><span class="line">              u32 insert_at;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (extra_len &gt; temp_len) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              insert_at = UR(temp_len - extra_len + <span class="number">1</span>);</span><br><span class="line">              <span class="built_in">memcpy</span>(out_buf + insert_at, extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>: &#123;</span><br><span class="line"></span><br><span class="line">            u32 use_extra, extra_len, insert_at = UR(temp_len + <span class="number">1</span>);</span><br><span class="line">            u8* new_buf;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Insert an extra. Do the same dice-rolling stuff as for the</span></span><br><span class="line"><span class="comment">               previous case. */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!extras_cnt || (a_extras_cnt &amp;&amp; UR(<span class="number">2</span>))) &#123;</span><br><span class="line"></span><br><span class="line">              use_extra = UR(a_extras_cnt);</span><br><span class="line">              extra_len = a_extras[use_extra].len;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (temp_len + extra_len &gt;= MAX_FILE) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              new_buf = ck_alloc_nozero(temp_len + extra_len);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Head */</span></span><br><span class="line">              <span class="built_in">memcpy</span>(new_buf, out_buf, insert_at);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Inserted part */</span></span><br><span class="line">              <span class="built_in">memcpy</span>(new_buf + insert_at, a_extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">              use_extra = UR(extras_cnt);</span><br><span class="line">              extra_len = extras[use_extra].len;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (temp_len + extra_len &gt;= MAX_FILE) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              new_buf = ck_alloc_nozero(temp_len + extra_len);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Head */</span></span><br><span class="line">              <span class="built_in">memcpy</span>(new_buf, out_buf, insert_at);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Inserted part */</span></span><br><span class="line">              <span class="built_in">memcpy</span>(new_buf + insert_at, extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Tail */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf + insert_at + extra_len, out_buf + insert_at,</span><br><span class="line">                   temp_len - insert_at);</span><br><span class="line"></span><br><span class="line">            ck_free(out_buf);</span><br><span class="line">            out_buf   = new_buf;</span><br><span class="line">            temp_len += extra_len;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, temp_len))</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* out_buf might have been mangled a bit, so let&#x27;s restore it to its</span></span><br><span class="line"><span class="comment">       original size and shape. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (temp_len &lt; len) out_buf = ck_realloc(out_buf, len);</span><br><span class="line">    temp_len = len;</span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we&#x27;re finding new stuff, let&#x27;s run for a bit longer, limits</span></span><br><span class="line"><span class="comment">       permitting. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queued_paths != havoc_queued) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (perf_score &lt;= HAVOC_MAX_MULT * <span class="number">100</span>) &#123;</span><br><span class="line">        stage_max  *= <span class="number">2</span>;</span><br><span class="line">        perf_score *= <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      havoc_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!splice_cycle) &#123;</span><br><span class="line">    stage_finds[STAGE_HAVOC]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">    stage_cycles[STAGE_HAVOC] += stage_max;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    stage_finds[STAGE_SPLICE]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">    stage_cycles[STAGE_SPLICE] += stage_max;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>havoc 便是各种随机的变异，每一轮都会将多种变异方式组合（stacked）而成，选择哪些变异方案也是随机的，具体而言如下：</p>
<ul>
<li>case 0 ：随机选取某个比特翻转</li>
<li>case 1 ：随机选取 byte 改成 interesting value</li>
<li>case 2 ：随机选取 word 改成 interesting value ，并随机选择大小端序</li>
<li>case 3 ：随机选取 dword 改成 interesting value ，并随机选择大小端序</li>
<li>case 4 ：随机选取 byte 减去一个随机数</li>
<li>case 5 ：随机选取 byte 加上一个随机数</li>
<li>case 6 ：随机选取 word 减去一个随机数 ，并随机选择大小端序</li>
<li>case 7 ：随机选取 word 加上一个随机数 ，并随机选择大小端序</li>
<li>case 8 ：随机选取 dword 减去一个随机数 ，并随机选择大小端序</li>
<li>case 9 ：随机选取 dword 加上一个随机数 ，并随机选择大小端序</li>
<li>case 10 ：随机选取 byte 将其设置为随机数</li>
<li>case 11&#x2F;12 ：随机删除一段 bytes</li>
<li>case 13 ：随机一个位置，插入一段随机长度的内容<ul>
<li>75% 概率为原文中随机位置的内容</li>
<li>25% 概率为随机选取的数</li>
</ul>
</li>
<li>case 14 ：随机一个位置，替换一段随机长度的内容<ul>
<li>75% 概率为原文中随机位置的内容</li>
<li>25% 概率为随机选取的数</li>
</ul>
</li>
<li>case 15 ：随机一个位置，替换成 extras 内容（用户指定或自动生成的）</li>
<li>case 16 ：随机一个位置，插入 extras 内容（用户指定或自动生成的）</li>
</ul>
<h3 id="SPLICING阶段"><a href="#SPLICING阶段" class="headerlink" title="SPLICING阶段"></a>SPLICING阶段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> IGNORE_FINDS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/************</span></span><br><span class="line"><span class="comment">   * SPLICING *</span></span><br><span class="line"><span class="comment">   ************/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is a last-resort strategy triggered by a full round with no findings.</span></span><br><span class="line"><span class="comment">     It takes the current input file, randomly selects another input, and</span></span><br><span class="line"><span class="comment">     splices them together at some offset, then relies on the havoc</span></span><br><span class="line"><span class="comment">     code to mutate that blob. */</span></span><br><span class="line"></span><br><span class="line">retry_splicing:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (use_splicing &amp;&amp; splice_cycle++ &lt; SPLICE_CYCLES &amp;&amp;</span><br><span class="line">      queued_paths &gt; <span class="number">1</span> &amp;&amp; queue_cur-&gt;len &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">target</span>;</span></span><br><span class="line">    u32 tid, split_at;</span><br><span class="line">    u8* new_buf;</span><br><span class="line">    s32 f_diff, l_diff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First of all, if we&#x27;ve modified in_buf for havoc, let&#x27;s clean that</span></span><br><span class="line"><span class="comment">       up... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_buf != orig_in) &#123;</span><br><span class="line">      ck_free(in_buf);</span><br><span class="line">      in_buf = orig_in;</span><br><span class="line">      len = queue_cur-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pick a random queue entry and seek to it. Don&#x27;t splice with yourself. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123; tid = UR(queued_paths); &#125; <span class="keyword">while</span> (tid == current_entry);</span><br><span class="line"></span><br><span class="line">    splicing_with = tid;</span><br><span class="line">    target = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tid &gt;= <span class="number">100</span>) &#123; target = target-&gt;next_100; tid -= <span class="number">100</span>; &#125;</span><br><span class="line">    <span class="keyword">while</span> (tid--) target = target-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure that the target has a reasonable length. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (target &amp;&amp; (target-&gt;len &lt; <span class="number">2</span> || target == queue_cur)) &#123;</span><br><span class="line">      target = target-&gt;next;</span><br><span class="line">      splicing_with++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!target) <span class="keyword">goto</span> retry_splicing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read the testcase into a new buffer. */</span></span><br><span class="line"></span><br><span class="line">    fd = open(target-&gt;fname, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, target-&gt;fname);</span><br><span class="line"></span><br><span class="line">    new_buf = ck_alloc_nozero(target-&gt;len);</span><br><span class="line"></span><br><span class="line">    ck_read(fd, new_buf, target-&gt;len, target-&gt;fname);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find a suitable splicing location, somewhere between the first and</span></span><br><span class="line"><span class="comment">       the last differing byte. Bail out if the difference is just a single</span></span><br><span class="line"><span class="comment">       byte or so. */</span></span><br><span class="line"></span><br><span class="line">    locate_diffs(in_buf, new_buf, MIN(len, target-&gt;len), &amp;f_diff, &amp;l_diff);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f_diff &lt; <span class="number">0</span> || l_diff &lt; <span class="number">2</span> || f_diff == l_diff) &#123;</span><br><span class="line">      ck_free(new_buf);</span><br><span class="line">      <span class="keyword">goto</span> retry_splicing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split somewhere between the first and last differing byte. */</span></span><br><span class="line"></span><br><span class="line">    split_at = f_diff + UR(l_diff - f_diff);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do the thing. */</span></span><br><span class="line"></span><br><span class="line">    len = target-&gt;len;</span><br><span class="line">    <span class="built_in">memcpy</span>(new_buf, in_buf, split_at);</span><br><span class="line">    in_buf = new_buf;</span><br><span class="line"></span><br><span class="line">    ck_free(out_buf);</span><br><span class="line">    out_buf = ck_alloc_nozero(len);</span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !IGNORE_FINDS */</span></span></span><br><span class="line"></span><br><span class="line">  ret_val = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果没有定义 IGNORE_FINDS ，则进入该阶段</li>
<li>具体而言就是获取当前输入文件，然后随机选择另一个输入，并在某个偏移处将它们拼接在一起来进行测试</li>
</ul>
<h3 id="abandon-entry"><a href="#abandon-entry" class="headerlink" title="abandon_entry"></a>abandon_entry</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">abandon_entry:</span><br><span class="line"></span><br><span class="line">  splicing_with = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Update pending_not_fuzzed count if we made it through the calibration</span></span><br><span class="line"><span class="comment">     cycle and have not seen this entry before. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!stop_soon &amp;&amp; !queue_cur-&gt;cal_failed &amp;&amp; !queue_cur-&gt;was_fuzzed) &#123;</span><br><span class="line">    queue_cur-&gt;was_fuzzed = <span class="number">1</span>;</span><br><span class="line">    pending_not_fuzzed--;</span><br><span class="line">    <span class="keyword">if</span> (queue_cur-&gt;favored) pending_favored--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  munmap(orig_in, queue_cur-&gt;len);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_buf != orig_in) ck_free(in_buf);</span><br><span class="line">  ck_free(out_buf);</span><br><span class="line">  ck_free(eff_map);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret_val;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> FLIP_BIT</span></span><br></pre></td></tr></table></figure>

<p>最后的收尾阶段</p>
<h2 id="common-fuzz-stuff"><a href="#common-fuzz-stuff" class="headerlink" title="common_fuzz_stuff"></a>common_fuzz_stuff</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Write a modified test case, run program, process results. Handle</span></span><br><span class="line"><span class="comment">   error conditions, returning 1 if it&#x27;s time to bail out. This is</span></span><br><span class="line"><span class="comment">   a helper function for fuzz_one(). */</span></span><br><span class="line"></span><br><span class="line">EXP_ST u8 <span class="title function_">common_fuzz_stuff</span><span class="params">(<span class="type">char</span>** argv, u8* out_buf, u32 len)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8 fault;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (post_handler) &#123;</span><br><span class="line"></span><br><span class="line">    out_buf = post_handler(out_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (!out_buf || !len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  write_to_testcase(out_buf, len);</span><br><span class="line"></span><br><span class="line">  fault = run_target(argv, exec_tmout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fault == FAULT_TMOUT) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subseq_tmouts++ &gt; TMOUT_LIMIT) &#123;</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> subseq_tmouts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Users can hit us with SIGUSR1 to request the current input</span></span><br><span class="line"><span class="comment">     to be abandoned. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_requested) &#123;</span><br><span class="line"></span><br><span class="line">     skip_requested = <span class="number">0</span>;</span><br><span class="line">     cur_skipped_paths++;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This handles FAULT_ERROR for us: */</span></span><br><span class="line"></span><br><span class="line">  queued_discovered += save_if_interesting(argv, out_buf, len, fault);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(stage_cur % stats_update_freq) || stage_cur + <span class="number">1</span> == stage_max)</span><br><span class="line">    show_stats();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写修改后的测试用例，运行程序，处理结果。 处理错误情况，如果需要退出，则返回 1。 这是 fuzz_one() 的辅助函数</p>
<ul>
<li>post_handler 可以做一层 wrapper 再进行写入</li>
</ul>
<h2 id="trim-case"><a href="#trim-case" class="headerlink" title="trim_case"></a><strong><strong>trim_case</strong></strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Trim all new test cases to save cycles when doing deterministic checks. The</span></span><br><span class="line"><span class="comment">   trimmer uses power-of-two increments somewhere between 1/16 and 1/1024 of</span></span><br><span class="line"><span class="comment">   file size, to keep the stage short and sweet. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u8 <span class="title function_">trim_case</span><span class="params">(<span class="type">char</span>** argv, <span class="keyword">struct</span> queue_entry* q, u8* in_buf)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 tmp[<span class="number">64</span>];</span><br><span class="line">  <span class="type">static</span> u8 clean_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8  needs_write = <span class="number">0</span>, fault = <span class="number">0</span>;</span><br><span class="line">  u32 trim_exec = <span class="number">0</span>;</span><br><span class="line">  u32 remove_len;</span><br><span class="line">  u32 len_p2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Although the trimmer will be less useful when variable behavior is</span></span><br><span class="line"><span class="comment">     detected, it will still work to some extent, so we don&#x27;t check for</span></span><br><span class="line"><span class="comment">     this. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;len &lt; <span class="number">5</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  stage_name = tmp;</span><br><span class="line">  bytes_trim_in += q-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select initial chunk len, starting with large steps. */</span></span><br><span class="line"></span><br><span class="line">  len_p2 = next_p2(q-&gt;len);</span><br><span class="line"></span><br><span class="line">  remove_len = MAX(len_p2 / TRIM_START_STEPS, TRIM_MIN_BYTES);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Continue until the number of steps gets too high or the stepover</span></span><br><span class="line"><span class="comment">     gets too small. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (remove_len &gt;= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES)) &#123;</span><br><span class="line"></span><br><span class="line">    u32 remove_pos = remove_len;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;trim %s/%s&quot;</span>, DI(remove_len), DI(remove_len));</span><br><span class="line"></span><br><span class="line">    stage_cur = <span class="number">0</span>;</span><br><span class="line">    stage_max = q-&gt;len / remove_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (remove_pos &lt; q-&gt;len) &#123;</span><br><span class="line"></span><br><span class="line">      u32 trim_avail = MIN(remove_len, q-&gt;len - remove_pos);</span><br><span class="line">      u32 cksum;</span><br><span class="line"></span><br><span class="line">      write_with_gap(in_buf, q-&gt;len, remove_pos, trim_avail);</span><br><span class="line"></span><br><span class="line">      fault = run_target(argv, exec_tmout);</span><br><span class="line">      trim_execs++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stop_soon || fault == FAULT_ERROR) <span class="keyword">goto</span> abort_trimming;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Note that we don&#x27;t keep track of crashes or hangs here; maybe TODO? */</span></span><br><span class="line"></span><br><span class="line">      cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If the deletion had no impact on the trace, make it permanent. This</span></span><br><span class="line"><span class="comment">         isn&#x27;t perfect for variable-path inputs, but we&#x27;re just making a</span></span><br><span class="line"><span class="comment">         best-effort pass, so it&#x27;s not a big deal if we end up with false</span></span><br><span class="line"><span class="comment">         negatives every now and then. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cksum == q-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        u32 move_tail = q-&gt;len - remove_pos - trim_avail;</span><br><span class="line"></span><br><span class="line">        q-&gt;len -= trim_avail;</span><br><span class="line">        len_p2  = next_p2(q-&gt;len);</span><br><span class="line"></span><br><span class="line">        memmove(in_buf + remove_pos, in_buf + remove_pos + trim_avail, </span><br><span class="line">                move_tail);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Let&#x27;s save a clean trace, which will be needed by</span></span><br><span class="line"><span class="comment">           update_bitmap_score once we&#x27;re done with the trimming stuff. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!needs_write) &#123;</span><br><span class="line"></span><br><span class="line">          needs_write = <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">memcpy</span>(clean_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> remove_pos += remove_len;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Since this can be slow, update the screen every now and then. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!(trim_exec++ % stats_update_freq)) show_stats();</span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remove_len &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we have made changes to in_buf, we also need to update the on-disk</span></span><br><span class="line"><span class="comment">     version of the test case. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (needs_write) &#123;</span><br><span class="line"></span><br><span class="line">    s32 fd;</span><br><span class="line"></span><br><span class="line">    unlink(q-&gt;fname); <span class="comment">/* ignore errors */</span></span><br><span class="line"></span><br><span class="line">    fd = open(q-&gt;fname, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    ck_write(fd, in_buf, q-&gt;len, q-&gt;fname);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(trace_bits, clean_trace, MAP_SIZE);</span><br><span class="line">    update_bitmap_score(q);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">abort_trimming:</span><br><span class="line"></span><br><span class="line">  bytes_trim_out += q-&gt;len;</span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当传入的 q-&gt;len 小于 5 的时候，直接返回 0</p>
</li>
<li><p>设置 stage_name 为 tmp ，bytes_trim_in 加上 q-&gt;len</p>
</li>
<li><p>计算 len_p2 为 next_p2(q-&gt;len)，也就是比如 3 会得到 4</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Find first power of two greater or equal to val (assuming val under</span></span><br><span class="line"><span class="comment">   2^31). */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u32 <span class="title function_">next_p2</span><span class="params">(u32 val)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (val &gt; ret) ret &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算 remove_len 为 MAX(len_p2 &#x2F; TRIM_START_STEPS, TRIM_MIN_BYTES) ，也就是需要移除的长度</p>
</li>
<li><p>当 remove_len 大于等于 MAX(len_p2 &#x2F; TRIM_END_STEPS, TRIM_MIN_BYTES) 的时候，进行循环，每次 remove_len 会除 2</p>
<ul>
<li>设置 remove_pos 为 remove_len ，stage_cur 为 0 ，stage_max 为 q-&gt;len &#x2F; remove_len</li>
<li>当 remove_pos 小于 q-&gt;len 的时候，进行循环，也就是每次前进 remove_len 长度直到文件被遍历完<ul>
<li>设置 trim_avail 为 MIN(remove_len, q-&gt;len - remove_pos)</li>
<li>调用 write_with_gap(in_buf, q-&gt;len, remove_pos, trim_avail)<ul>
<li>从 in_buf 的 remove_pos 开始向后跳过 remove_len 长度，写入到 .cur_input 中</li>
</ul>
</li>
<li>调用 run_target(argv, exec_tmout) 并将返回值存储在 fault 中</li>
<li>递增 trim_execs</li>
<li>如果设置了 stop_soon 或 fault 为 FAULT_ERROR ，跳到 abort_trimming</li>
<li>计算 cksum 等于 hash32(trace_bits, MAP_SIZE, HASH_CONST)</li>
<li>将 cksum 和 q-&gt;exec_cksum 进行比较，如果相等<ul>
<li>设置 move_tail 为 q-&gt;len - remove_pos - trim_avail</li>
<li>将 q→len 减去 trim_avail 并重新计算 len_p2</li>
<li>相等的话则从 in_buf + remove_pos + trim_avail 处移动 move_tail 字节到 in_buf + remove_pos</li>
<li>如果没有设置 needs_write ，则设置 needs_write 为 1 并将 trace_bits 拷贝到 clean_trace 中</li>
</ul>
</li>
<li>否则不相等，将 remove_pos 加上 remove_len</li>
</ul>
</li>
<li>定期 show_stats 并递增 stage_cur</li>
</ul>
</li>
<li><p>如果设置了 needs_write ，删除原来的 q-&gt;fname 并创建一个新的，将 in_buf 写进去并将 clean_trace 内容拷贝到 trace_bits ，最后调用 update_bitmap_score(q)</p>
</li>
<li><p>返回 fault</p>
</li>
</ul>
<h2 id="calculate-score"><a href="#calculate-score" class="headerlink" title="calculate_score"></a><strong><strong>calculate_score</strong></strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Calculate case desirability score to adjust the length of havoc fuzzing.</span></span><br><span class="line"><span class="comment">   A helper function for fuzz_one(). Maybe some of these constants should</span></span><br><span class="line"><span class="comment">   go into config.h. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u32 <span class="title function_">calculate_score</span><span class="params">(<span class="keyword">struct</span> queue_entry* q)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 avg_exec_us = total_cal_us / total_cal_cycles;</span><br><span class="line">  u32 avg_bitmap_size = total_bitmap_size / total_bitmap_entries;</span><br><span class="line">  u32 perf_score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust score based on execution speed of this path, compared to the</span></span><br><span class="line"><span class="comment">     global average. Multiplier ranges from 0.1x to 3x. Fast inputs are</span></span><br><span class="line"><span class="comment">     less expensive to fuzz, so we&#x27;re giving them more air time. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.1</span> &gt; avg_exec_us) perf_score = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.25</span> &gt; avg_exec_us) perf_score = <span class="number">25</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.5</span> &gt; avg_exec_us) perf_score = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.75</span> &gt; avg_exec_us) perf_score = <span class="number">75</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">4</span> &lt; avg_exec_us) perf_score = <span class="number">300</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">3</span> &lt; avg_exec_us) perf_score = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">2</span> &lt; avg_exec_us) perf_score = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust score based on bitmap size. The working theory is that better</span></span><br><span class="line"><span class="comment">     coverage translates to better targets. Multiplier from 0.25x to 3x. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.3</span> &gt; avg_bitmap_size) perf_score *= <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.5</span> &gt; avg_bitmap_size) perf_score *= <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.75</span> &gt; avg_bitmap_size) perf_score *= <span class="number">1.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">3</span> &lt; avg_bitmap_size) perf_score *= <span class="number">0.25</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">2</span> &lt; avg_bitmap_size) perf_score *= <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">1.5</span> &lt; avg_bitmap_size) perf_score *= <span class="number">0.75</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust score based on handicap. Handicap is proportional to how late</span></span><br><span class="line"><span class="comment">     in the game we learned about this path. Latecomers are allowed to run</span></span><br><span class="line"><span class="comment">     for a bit longer until they catch up with the rest. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;handicap &gt;= <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">    perf_score *= <span class="number">4</span>;</span><br><span class="line">    q-&gt;handicap -= <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;handicap) &#123;</span><br><span class="line"></span><br><span class="line">    perf_score *= <span class="number">2</span>;</span><br><span class="line">    q-&gt;handicap--;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Final adjustment based on input depth, under the assumption that fuzzing</span></span><br><span class="line"><span class="comment">     deeper test cases is more likely to reveal stuff that can&#x27;t be</span></span><br><span class="line"><span class="comment">     discovered with traditional fuzzers. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (q-&gt;depth) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> ... <span class="number">3</span>:   <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span> ... <span class="number">7</span>:   perf_score *= <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span> ... <span class="number">13</span>:  perf_score *= <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">14</span> ... <span class="number">25</span>: perf_score *= <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:        perf_score *= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure that we don&#x27;t go over limit. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (perf_score &gt; HAVOC_MAX_MULT * <span class="number">100</span>) perf_score = HAVOC_MAX_MULT * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> perf_score;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 queue_entry 的执行速度、覆盖到的路径数和深度来评估打分，并用作计算 fuzz_one 中后面随机变异部分的最大循环数</p>
<h2 id="save-if-interesting"><a href="#save-if-interesting" class="headerlink" title="save_if_interesting"></a><strong><strong>save_if_interesting</strong></strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if the result of an execve() during routine fuzzing is interesting,</span></span><br><span class="line"><span class="comment">   save or queue the input test case for further analysis if so. Returns 1 if</span></span><br><span class="line"><span class="comment">   entry is saved, 0 otherwise. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u8 <span class="title function_">save_if_interesting</span><span class="params">(<span class="type">char</span>** argv, <span class="type">void</span>* mem, u32 len, u8 fault)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8  *fn = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  u8  hnb;</span><br><span class="line">  s32 fd;</span><br><span class="line">  u8  keeping = <span class="number">0</span>, res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fault == crash_mode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep only if there are new bits in the map, add to queue for</span></span><br><span class="line"><span class="comment">       future fuzzing, etc. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(hnb = has_new_bits(virgin_bits))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (crash_mode) total_crashes++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/queue/id:%06u,%s&quot;</span>, out_dir, queued_paths,</span><br><span class="line">                      describe_op(hnb));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/queue/id_%06u&quot;</span>, out_dir, queued_paths);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">    add_to_queue(fn, len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hnb == <span class="number">2</span>) &#123;</span><br><span class="line">      queue_top-&gt;has_new_cov = <span class="number">1</span>;</span><br><span class="line">      queued_with_cov++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue_top-&gt;exec_cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to calibrate inline; this also calls update_bitmap_score() when</span></span><br><span class="line"><span class="comment">       successful. */</span></span><br><span class="line"></span><br><span class="line">    res = calibrate_case(argv, queue_top, mem, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">    ck_write(fd, mem, len, fn);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    keeping = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (fault) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_TMOUT:</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Timeouts are not very interesting, but we&#x27;re still obliged to keep</span></span><br><span class="line"><span class="comment">         a handful of samples. We use the presence of new bits in the</span></span><br><span class="line"><span class="comment">         hang-specific bitmap as a signal of uniqueness. In &quot;dumb&quot; mode, we</span></span><br><span class="line"><span class="comment">         just keep everything. */</span></span><br><span class="line"></span><br><span class="line">      total_tmouts++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (unique_hangs &gt;= KEEP_UNIQUE_HANG) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">        simplify_trace((u64*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        simplify_trace((u32*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!has_new_bits(virgin_tmout)) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      unique_tmouts++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Before saving, we make sure that it&#x27;s a genuine hang by re-running</span></span><br><span class="line"><span class="comment">         the target with a more generous timeout (unless the default timeout</span></span><br><span class="line"><span class="comment">         is already generous). */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (exec_tmout &lt; hang_tmout) &#123;</span><br><span class="line"></span><br><span class="line">        u8 new_fault;</span><br><span class="line">        write_to_testcase(mem, len);</span><br><span class="line">        new_fault = run_target(argv, hang_tmout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* A corner case that one user reported bumping into: increasing the</span></span><br><span class="line"><span class="comment">           timeout actually uncovers a crash. Make sure we don&#x27;t discard it if</span></span><br><span class="line"><span class="comment">           so. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!stop_soon &amp;&amp; new_fault == FAULT_CRASH) <span class="keyword">goto</span> keep_as_crash;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stop_soon || new_fault != FAULT_TMOUT) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"></span><br><span class="line">      fn = alloc_printf(<span class="string">&quot;%s/hangs/id:%06llu,%s&quot;</span>, out_dir,</span><br><span class="line">                        unique_hangs, describe_op(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      fn = alloc_printf(<span class="string">&quot;%s/hangs/id_%06llu&quot;</span>, out_dir,</span><br><span class="line">                        unique_hangs);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">      unique_hangs++;</span><br><span class="line"></span><br><span class="line">      last_hang_time = get_cur_time();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_CRASH:</span><br><span class="line"></span><br><span class="line">keep_as_crash:</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* This is handled in a manner roughly similar to timeouts,</span></span><br><span class="line"><span class="comment">         except for slightly different limits and no need to re-run test</span></span><br><span class="line"><span class="comment">         cases. */</span></span><br><span class="line"></span><br><span class="line">      total_crashes++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (unique_crashes &gt;= KEEP_UNIQUE_CRASH) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">        simplify_trace((u64*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        simplify_trace((u32*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!has_new_bits(virgin_crash)) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!unique_crashes) write_crash_readme();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"></span><br><span class="line">      fn = alloc_printf(<span class="string">&quot;%s/crashes/id:%06llu,sig:%02u,%s&quot;</span>, out_dir,</span><br><span class="line">                        unique_crashes, kill_signal, describe_op(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      fn = alloc_printf(<span class="string">&quot;%s/crashes/id_%06llu_%02u&quot;</span>, out_dir, unique_crashes,</span><br><span class="line">                        kill_signal);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">      unique_crashes++;</span><br><span class="line"></span><br><span class="line">      last_crash_time = get_cur_time();</span><br><span class="line">      last_crash_execs = total_execs;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_ERROR: FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we&#x27;re here, we apparently want to save the crash or hang</span></span><br><span class="line"><span class="comment">     test case, too. */</span></span><br><span class="line"></span><br><span class="line">  fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">  ck_write(fd, mem, len, fn);</span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查测试用例的执行结果是否有价值，如果有价值返回 1 ，否则返回 0</p>
<ul>
<li>如果 fault 等于 crash_mode ，没有发现新的 path 则返回 0</li>
<li>否则将 case 保存到 fn &#x3D; alloc_printf(“%s&#x2F;queue&#x2F;id:%06u,%s”, out_dir, queued_paths,<br>describe_op(hnb)) ，并将它添加到队列中</li>
<li>如果有新路径，更新 has_new_cov 为 1 并递增 queued_with_cov ，然后计算 exec_cksum</li>
<li>调用 calibrate_case(argv, queue_top, mem, queue_cycle - 1, 0) ，也就是评估该 queue ，并将结果存储到 res</li>
<li>根据 res 的值进行操作<ul>
<li>FAULT_TMOUT<ul>
<li>递增 total_tmouts</li>
<li>如果 unique_hangs 大于等于 KEEP_UNIQUE_HANG（500）则返回 keeping</li>
<li>如果不是 dumb 模式则调用 simplify_trace(trace_bits)，之后调用 has_new_bits 发现没有新的路径则返回 keeping</li>
<li>递增 unique_tmouts</li>
<li>如果 exec_tmout 小于 hang_tmout 则<ul>
<li>调用 write_to_testcase 写入测试用例并再次执行 run_target ，将结果存储在 new_fault 中</li>
<li>如果 stop_soon 为 0 且 new_fault 为 FAULT_CRASH 则跳到 keep_as_crash</li>
<li>如果定义了 stop_soon 或 new_fault 不等于 FAULT_TMOUT 则返回 keeping</li>
</ul>
</li>
<li>如果没有定义 SIMPLE_FILES 则存储用例在 hangs 目录下</li>
<li>递增 unique_hangs 并获取 last_hang_time</li>
</ul>
</li>
<li>FAULT_CRASH<ul>
<li>开头便是 keep_as_crash</li>
<li>递增 total_crashes</li>
<li>如果 unique_crashes 大于等于 KEEP_UNIQUE_CRASH（5000）则返回 keeping</li>
<li>如果不是 dumb 模式则调用 simplify_trace(trace_bits)，之后调用 has_new_bits 发现没有新的路径则返回 keeping</li>
<li>如果没有定义 unique_crashes 则 write_crash_readme</li>
<li>如果没有定义 SIMPLE_FILES 则存储用例在 crashes 目录下</li>
<li>递增 unique_crashes  并获取 last_hang_time ，同时更新 last_crash_execs 为 total_execs</li>
</ul>
</li>
<li>FAULT_ERROR<ul>
<li>抛出异常</li>
</ul>
</li>
<li>default<ul>
<li>返回 keeping</li>
</ul>
</li>
</ul>
</li>
<li>最后写入 fn</li>
</ul>
<h2 id="sync-fuzzers"><a href="#sync-fuzzers" class="headerlink" title="sync_fuzzers"></a><strong><strong>sync_fuzzers</strong></strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Grab interesting test cases from other fuzzers. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sync_fuzzers</span><span class="params">(<span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  DIR* sd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">sd_ent</span>;</span></span><br><span class="line">  u32 sync_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  sd = opendir(sync_dir);</span><br><span class="line">  <span class="keyword">if</span> (!sd) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, sync_dir);</span><br><span class="line"></span><br><span class="line">  stage_max = stage_cur = <span class="number">0</span>;</span><br><span class="line">  cur_depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Look at the entries created for every other fuzzer in the sync directory. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((sd_ent = readdir(sd))) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> u8 stage_tmp[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    DIR* qd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">qd_ent</span>;</span></span><br><span class="line">    u8 *qd_path, *qd_synced_path;</span><br><span class="line">    u32 min_accept = <span class="number">0</span>, next_min_accept;</span><br><span class="line"></span><br><span class="line">    s32 id_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip dot files and our own output directory. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sd_ent-&gt;d_name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> || !<span class="built_in">strcmp</span>(sync_id, sd_ent-&gt;d_name)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip anything that doesn&#x27;t have a queue/ subdirectory. */</span></span><br><span class="line"></span><br><span class="line">    qd_path = alloc_printf(<span class="string">&quot;%s/%s/queue&quot;</span>, sync_dir, sd_ent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(qd = opendir(qd_path))) &#123;</span><br><span class="line">      ck_free(qd_path);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Retrieve the ID of the last seen test case. */</span></span><br><span class="line"></span><br><span class="line">    qd_synced_path = alloc_printf(<span class="string">&quot;%s/.synced/%s&quot;</span>, out_dir, sd_ent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    id_fd = open(qd_synced_path, O_RDWR | O_CREAT, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id_fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, qd_synced_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(id_fd, &amp;min_accept, <span class="keyword">sizeof</span>(u32)) &gt; <span class="number">0</span>) </span><br><span class="line">      lseek(id_fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    next_min_accept = min_accept;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Show stats */</span>    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(stage_tmp, <span class="string">&quot;sync %u&quot;</span>, ++sync_cnt);</span><br><span class="line">    stage_name = stage_tmp;</span><br><span class="line">    stage_cur  = <span class="number">0</span>;</span><br><span class="line">    stage_max  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For every file queued by this fuzzer, parse ID and see if we have looked at</span></span><br><span class="line"><span class="comment">       it before; exec a test case if not. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((qd_ent = readdir(qd))) &#123;</span><br><span class="line"></span><br><span class="line">      u8* path;</span><br><span class="line">      s32 fd;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (qd_ent-&gt;d_name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> ||</span><br><span class="line">          <span class="built_in">sscanf</span>(qd_ent-&gt;d_name, CASE_PREFIX <span class="string">&quot;%06u&quot;</span>, &amp;syncing_case) != <span class="number">1</span> || </span><br><span class="line">          syncing_case &lt; min_accept) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* OK, sounds like a new one. Let&#x27;s give it a try. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (syncing_case &gt;= next_min_accept)</span><br><span class="line">        next_min_accept = syncing_case + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      path = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, qd_path, qd_ent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Allow this to fail in case the other fuzzer is resuming or so... */</span></span><br><span class="line"></span><br><span class="line">      fd = open(path, O_RDONLY);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         ck_free(path);</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fstat(fd, &amp;st)) PFATAL(<span class="string">&quot;fstat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Ignore zero-sized or oversized files. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (st.st_size &amp;&amp; st.st_size &lt;= MAX_FILE) &#123;</span><br><span class="line"></span><br><span class="line">        u8  fault;</span><br><span class="line">        u8* mem = mmap(<span class="number">0</span>, st.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mem == MAP_FAILED) PFATAL(<span class="string">&quot;Unable to mmap &#x27;%s&#x27;&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* See what happens. We rely on save_if_interesting() to catch major</span></span><br><span class="line"><span class="comment">           errors and save the test case. */</span></span><br><span class="line"></span><br><span class="line">        write_to_testcase(mem, st.st_size);</span><br><span class="line"></span><br><span class="line">        fault = run_target(argv, exec_tmout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        syncing_party = sd_ent-&gt;d_name;</span><br><span class="line">        queued_imported += save_if_interesting(argv, mem, st.st_size, fault);</span><br><span class="line">        syncing_party = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        munmap(mem, st.st_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(stage_cur++ % stats_update_freq)) show_stats();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ck_free(path);</span><br><span class="line">      close(fd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ck_write(id_fd, &amp;next_min_accept, <span class="keyword">sizeof</span>(u32), qd_synced_path);</span><br><span class="line"></span><br><span class="line">    close(id_fd);</span><br><span class="line">    closedir(qd);</span><br><span class="line">    ck_free(qd_path);</span><br><span class="line">    ck_free(qd_synced_path);</span><br><span class="line">    </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  closedir(sd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数将其他 .synced 文件夹下的 queue 文件读取到自己的队列中并运行测试</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Vergissmeinnicht</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://vergissmeinnichtz.github.io/2022/03/14/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-afl-fuzz/">https://vergissmeinnichtz.github.io/2022/03/14/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-afl-fuzz/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/03/14/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-afl-clang-fast/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">AFL源码阅读 - afl-clang-fast</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/04/29/RkrKDQiodbYj2eu.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Vergissmeinnicht</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">38</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">32</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Vergissmeinnichtz"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Vergissmeinnichtz" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:verhan@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Live Long And Pwn.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">初始配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">输入参数处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setup-signal-handlers"><span class="toc-number">2.2.</span> <span class="toc-text">setup_signal_handlers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#check-asan-opts"><span class="toc-number">2.3.</span> <span class="toc-text">check_asan_opts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fix-up-sync"><span class="toc-number">2.4.</span> <span class="toc-text">fix_up_sync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%9A%84%E6%A3%80%E6%9F%A5%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-number">2.5.</span> <span class="toc-text">输入的检查和环境变量的读取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#save-cmdline"><span class="toc-number">2.6.</span> <span class="toc-text">save_cmdline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fix-up-banner"><span class="toc-number">2.7.</span> <span class="toc-text">fix_up_banner</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#check-if-tty"><span class="toc-number">2.8.</span> <span class="toc-text">check_if_tty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-core-count"><span class="toc-number">2.9.</span> <span class="toc-text">get_core_count</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bind-to-free-cpu"><span class="toc-number">2.10.</span> <span class="toc-text">bind_to_free_cpu</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#check-crash-handling"><span class="toc-number">2.11.</span> <span class="toc-text">check_crash_handling</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#check-cpu-governor"><span class="toc-number">2.12.</span> <span class="toc-text">check_cpu_governor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setup-post"><span class="toc-number">2.13.</span> <span class="toc-text">setup_post</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setup-shm"><span class="toc-number">2.14.</span> <span class="toc-text">setup_shm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init-count-class16"><span class="toc-number">2.15.</span> <span class="toc-text">init_count_class16</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setup-dirs-fds"><span class="toc-number">2.16.</span> <span class="toc-text">setup_dirs_fds</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read-testcases"><span class="toc-number">2.17.</span> <span class="toc-text">read_testcases</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#add-to-queue"><span class="toc-number">2.18.</span> <span class="toc-text">add_to_queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load-auto"><span class="toc-number">2.19.</span> <span class="toc-text">load_auto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pivot-inputs"><span class="toc-number">2.20.</span> <span class="toc-text">pivot_inputs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load-extras"><span class="toc-number">2.21.</span> <span class="toc-text">load_extras</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#find-timeout"><span class="toc-number">2.22.</span> <span class="toc-text">find_timeout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#detect-file-args"><span class="toc-number">2.23.</span> <span class="toc-text">detect_file_args</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setup-stdio-file"><span class="toc-number">2.24.</span> <span class="toc-text">setup_stdio_file</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#check-binary"><span class="toc-number">2.25.</span> <span class="toc-text">check_binary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A6%96%E6%AC%A1-Fuzz"><span class="toc-number">3.</span> <span class="toc-text">首次 Fuzz</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#start-time"><span class="toc-number">3.1.</span> <span class="toc-text">start_time</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-qemu-argv"><span class="toc-number">3.2.</span> <span class="toc-text">get_qemu_argv</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#perform-dry-run"><span class="toc-number">3.3.</span> <span class="toc-text">perform_dry_run</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#calibrate-case"><span class="toc-number">3.4.</span> <span class="toc-text">calibrate_case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init-forkserver"><span class="toc-number">3.5.</span> <span class="toc-text">init_forkserver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#has-new-bits"><span class="toc-number">3.6.</span> <span class="toc-text">has_new_bits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#run-target"><span class="toc-number">3.7.</span> <span class="toc-text">run_target</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#update-bitmap-score"><span class="toc-number">3.8.</span> <span class="toc-text">update_bitmap_score</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cull-queue"><span class="toc-number">3.9.</span> <span class="toc-text">cull_queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mark-as-redundant"><span class="toc-number">3.10.</span> <span class="toc-text">mark_as_redundant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#show-init-stats"><span class="toc-number">3.11.</span> <span class="toc-text">show_init_stats</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#find-start-position"><span class="toc-number">3.12.</span> <span class="toc-text">find_start_position</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#write-stats-file"><span class="toc-number">3.13.</span> <span class="toc-text">write_stats_file</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#save-auto"><span class="toc-number">3.14.</span> <span class="toc-text">save_auto</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fuzz-%E6%89%A7%E8%A1%8C"><span class="toc-number">4.</span> <span class="toc-text">Fuzz 执行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.1.</span> <span class="toc-text">主循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fuzz-one"><span class="toc-number">4.2.</span> <span class="toc-text">fuzz_one</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#queue%E5%88%A4%E6%96%AD%E9%98%B6%E6%AE%B5"><span class="toc-number">4.2.1.</span> <span class="toc-text">queue判断阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CALIBRATION%E9%98%B6%E6%AE%B5"><span class="toc-number">4.2.2.</span> <span class="toc-text">CALIBRATION阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TRIMMING%E9%98%B6%E6%AE%B5"><span class="toc-number">4.2.3.</span> <span class="toc-text">TRIMMING阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PERFORMANCE-SCORE%E9%98%B6%E6%AE%B5"><span class="toc-number">4.2.4.</span> <span class="toc-text">PERFORMANCE SCORE阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SIMPLE-BITFLIP-dictionary-construction-%E9%98%B6%E6%AE%B5"><span class="toc-number">4.2.5.</span> <span class="toc-text">SIMPLE BITFLIP (+dictionary construction)阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARITHMETIC-INC-x2F-DEC%E9%98%B6%E6%AE%B5"><span class="toc-number">4.2.6.</span> <span class="toc-text">ARITHMETIC INC&#x2F;DEC阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INTERESTING-VALUES%E9%98%B6%E6%AE%B5"><span class="toc-number">4.2.7.</span> <span class="toc-text">INTERESTING VALUES阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DICTIONARY-STUFF%E9%98%B6%E6%AE%B5"><span class="toc-number">4.2.8.</span> <span class="toc-text">DICTIONARY STUFF阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RANDOM-HAVOC%E9%98%B6%E6%AE%B5"><span class="toc-number">4.2.9.</span> <span class="toc-text">RANDOM HAVOC阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPLICING%E9%98%B6%E6%AE%B5"><span class="toc-number">4.2.10.</span> <span class="toc-text">SPLICING阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abandon-entry"><span class="toc-number">4.2.11.</span> <span class="toc-text">abandon_entry</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#common-fuzz-stuff"><span class="toc-number">4.3.</span> <span class="toc-text">common_fuzz_stuff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trim-case"><span class="toc-number">4.4.</span> <span class="toc-text">trim_case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#calculate-score"><span class="toc-number">4.5.</span> <span class="toc-text">calculate_score</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#save-if-interesting"><span class="toc-number">4.6.</span> <span class="toc-text">save_if_interesting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-fuzzers"><span class="toc-number">4.7.</span> <span class="toc-text">sync_fuzzers</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/14/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-afl-fuzz/" title="AFL源码阅读 - afl-fuzz">AFL源码阅读 - afl-fuzz</a><time datetime="2022-03-14T09:35:50.000Z" title="Created 2022-03-14 17:35:50">2022-03-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/14/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-afl-clang-fast/" title="AFL源码阅读 - afl-clang-fast">AFL源码阅读 - afl-clang-fast</a><time datetime="2022-03-14T06:47:50.000Z" title="Created 2022-03-14 14:47:50">2022-03-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/13/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-afl-as/" title="AFL源码阅读 - afl-as">AFL源码阅读 - afl-as</a><time datetime="2022-03-13T07:04:50.000Z" title="Created 2022-03-13 15:04:50">2022-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/13/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-afl-gcc/" title="AFL源码阅读 - afl-gcc">AFL源码阅读 - afl-gcc</a><time datetime="2022-03-13T05:22:50.000Z" title="Created 2022-03-13 13:22:50">2022-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/05/CVE-2021-43226-%EF%BC%9ACLFS-%E4%B8%AD%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/" title="CVE-2021-43226 ：CLFS 中的栈溢出漏洞">CVE-2021-43226 ：CLFS 中的栈溢出漏洞</a><time datetime="2022-02-05T06:56:21.000Z" title="Created 2022-02-05 14:56:21">2022-02-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Vergissmeinnicht</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>